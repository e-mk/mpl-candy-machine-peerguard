"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const mpl_token_metadata_1 = require("@metaplex-foundation/mpl-token-metadata");
const umi_1 = require("@metaplex-foundation/umi");
const ava_1 = __importDefault(require("ava"));
const src_1 = require("../src");
const _setup_1 = require("./_setup");
(0, ava_1.default)('it can create a candy machine using config line settings', async (t) => {
    // Given an existing collection NFT.
    const umi = await (0, _setup_1.createUmi)();
    const collectionMint = await (0, _setup_1.createCollectionNft)(umi);
    // When we create a new candy machine with config line settings.
    const candyMachine = (0, umi_1.generateSigner)(umi);
    const creator = (0, umi_1.generateSigner)(umi);
    await (0, umi_1.transactionBuilder)()
        .add(await (0, src_1.createCandyMachineV2)(umi, {
        candyMachine,
        tokenStandard: mpl_token_metadata_1.TokenStandard.NonFungible,
        collectionMint: collectionMint.publicKey,
        collectionUpdateAuthority: umi.identity,
        itemsAvailable: 100,
        sellerFeeBasisPoints: (0, umi_1.percentAmount)(1.23),
        creators: [
            { address: creator.publicKey, verified: false, percentageShare: 100 },
        ],
        configLineSettings: (0, umi_1.some)({
            prefixName: 'My NFT #',
            nameLength: 8,
            prefixUri: 'https://example.com/',
            uriLength: 20,
            isSequential: false,
        }),
    }))
        .sendAndConfirm(umi);
    // Then we expect the candy machine account to have the right data.
    const candyMachineAccount = await (0, src_1.fetchCandyMachine)(umi, candyMachine.publicKey);
    t.like(candyMachineAccount, {
        publicKey: (0, umi_1.publicKey)(candyMachine),
        authority: (0, umi_1.publicKey)(umi.identity),
        mintAuthority: (0, umi_1.publicKey)(umi.identity),
        collectionMint: (0, umi_1.publicKey)(collectionMint),
        version: src_1.AccountVersion.V2,
        tokenStandard: mpl_token_metadata_1.TokenStandard.NonFungible,
        itemsRedeemed: 0n,
        data: {
            itemsAvailable: 100n,
            symbol: '',
            sellerFeeBasisPoints: (0, umi_1.percentAmount)(1.23),
            maxEditionSupply: 0n,
            isMutable: true,
            creators: [
                {
                    address: (0, umi_1.publicKey)(creator),
                    verified: false,
                    percentageShare: 100,
                },
            ],
            configLineSettings: (0, umi_1.some)({
                prefixName: 'My NFT #',
                nameLength: 8,
                prefixUri: 'https://example.com/',
                uriLength: 20,
                isSequential: false,
            }),
            hiddenSettings: (0, umi_1.none)(),
        },
    });
});
(0, ava_1.default)('it can create a candy machine using hidden settings', async (t) => {
    // Given an existing collection NFT.
    const umi = await (0, _setup_1.createUmi)();
    const collectionMint = await (0, _setup_1.createCollectionNft)(umi);
    // When we create a new candy machine with hidden settings.
    const candyMachine = (0, umi_1.generateSigner)(umi);
    const creator = (0, umi_1.generateSigner)(umi);
    await (0, umi_1.transactionBuilder)()
        .add(await (0, src_1.createCandyMachineV2)(umi, {
        candyMachine,
        tokenStandard: mpl_token_metadata_1.TokenStandard.NonFungible,
        collectionMint: collectionMint.publicKey,
        collectionUpdateAuthority: umi.identity,
        itemsAvailable: 100,
        sellerFeeBasisPoints: (0, umi_1.percentAmount)(1.23),
        creators: [
            { address: creator.publicKey, verified: false, percentageShare: 100 },
        ],
        hiddenSettings: (0, umi_1.some)({
            name: 'My NFT #$ID+1$',
            uri: 'https://example.com/$ID+1$.json',
            hash: new Uint8Array(Array(32).fill(42)),
        }),
    }))
        .sendAndConfirm(umi);
    // Then we expect the candy machine account to have the right data.
    const candyMachineAccount = await (0, src_1.fetchCandyMachine)(umi, candyMachine.publicKey);
    t.like(candyMachineAccount, {
        publicKey: (0, umi_1.publicKey)(candyMachine),
        authority: (0, umi_1.publicKey)(umi.identity),
        mintAuthority: (0, umi_1.publicKey)(umi.identity),
        collectionMint: (0, umi_1.publicKey)(collectionMint),
        version: src_1.AccountVersion.V2,
        tokenStandard: mpl_token_metadata_1.TokenStandard.NonFungible,
        itemsRedeemed: 0n,
        data: {
            itemsAvailable: 100n,
            symbol: '',
            sellerFeeBasisPoints: (0, umi_1.percentAmount)(1.23),
            maxEditionSupply: 0n,
            isMutable: true,
            creators: [
                {
                    address: (0, umi_1.publicKey)(creator),
                    verified: false,
                    percentageShare: 100,
                },
            ],
            configLineSettings: (0, umi_1.none)(),
            hiddenSettings: (0, umi_1.some)({
                name: 'My NFT #$ID+1$',
                uri: 'https://example.com/$ID+1$.json',
                hash: new Uint8Array(Array(32).fill(42)),
            }),
        },
    });
});
(0, ava_1.default)('it cannot create a candy machine without hidden or config line settings', async (t) => {
    // Given an existing collection NFT.
    const umi = await (0, _setup_1.createUmi)();
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    // When we try to create a new candy machine without any settings.
    const candyMachine = (0, umi_1.generateSigner)(umi);
    const promise = (0, umi_1.transactionBuilder)()
        .add(await (0, src_1.createCandyMachineV2)(umi, {
        ...(0, _setup_1.defaultCandyMachineData)(umi),
        collectionMint,
        candyMachine,
        configLineSettings: (0, umi_1.none)(),
        hiddenSettings: (0, umi_1.none)(),
    }))
        .sendAndConfirm(umi);
    // Then we expect a program error.
    await t.throwsAsync(promise, { message: /A raw constraint was violated/ });
});
(0, ava_1.default)('it can create a candy machine of Programmable NFTs', async (t) => {
    // Given an existing collection NFT.
    const umi = await (0, _setup_1.createUmi)();
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    // When we create a new candy machine using the Programmable NFTs standard.
    const candyMachine = (0, umi_1.generateSigner)(umi);
    await (0, umi_1.transactionBuilder)()
        .add(await (0, src_1.createCandyMachineV2)(umi, {
        ...(0, _setup_1.defaultCandyMachineData)(umi),
        candyMachine,
        collectionMint,
        tokenStandard: mpl_token_metadata_1.TokenStandard.ProgrammableNonFungible,
    }))
        .sendAndConfirm(umi);
    // Then we expect the candy machine account to have the right data.
    const candyMachineAccount = await (0, src_1.fetchCandyMachine)(umi, candyMachine.publicKey);
    t.like(candyMachineAccount, {
        publicKey: (0, umi_1.publicKey)(candyMachine),
        version: src_1.AccountVersion.V2,
        tokenStandard: mpl_token_metadata_1.TokenStandard.ProgrammableNonFungible,
    });
});
(0, ava_1.default)("it can create a candy machine that's bigger than 10Kb", async (t) => {
    // Given an existing collection NFT.
    const umi = await (0, _setup_1.createUmi)();
    const collectionMint = await (0, _setup_1.createCollectionNft)(umi);
    // When we create a new candy machine with a large amount of items.
    const candyMachine = (0, umi_1.generateSigner)(umi);
    await (0, umi_1.transactionBuilder)()
        .add(await (0, src_1.createCandyMachineV2)(umi, {
        ...(0, _setup_1.defaultCandyMachineData)(umi),
        candyMachine,
        itemsAvailable: 20000,
        tokenStandard: mpl_token_metadata_1.TokenStandard.NonFungible,
        collectionMint: collectionMint.publicKey,
    }))
        .sendAndConfirm(umi);
    // Then we expect the candy machine account to have been created.
    const candyMachineAccount = await (0, src_1.fetchCandyMachine)(umi, candyMachine.publicKey);
    t.like(candyMachineAccount, {
        publicKey: (0, umi_1.publicKey)(candyMachine),
        itemsRedeemed: 0n,
        data: { itemsAvailable: 20000n },
    });
});
(0, ava_1.default)('it can create a candy machine with an explicit rule set', async (t) => {
    // Given an existing collection NFT.
    const umi = await (0, _setup_1.createUmi)();
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    // When we create a new PNFT candy machine using an explicit rule set.
    const candyMachine = (0, umi_1.generateSigner)(umi);
    const metaplexDefaultRuleSet = (0, umi_1.publicKey)('eBJLFYPxJmMGKuFwpDWkzxZeUrad92kZRC5BJLpzyT9');
    await (0, umi_1.transactionBuilder)()
        .add(await (0, src_1.createCandyMachineV2)(umi, {
        ...(0, _setup_1.defaultCandyMachineData)(umi),
        candyMachine,
        collectionMint,
        tokenStandard: mpl_token_metadata_1.TokenStandard.ProgrammableNonFungible,
        ruleSet: metaplexDefaultRuleSet,
    }))
        .sendAndConfirm(umi);
    // Then we expect the candy machine account to store that information.
    const candyMachineAccount = await (0, src_1.fetchCandyMachine)(umi, candyMachine.publicKey);
    t.like(candyMachineAccount, {
        publicKey: (0, umi_1.publicKey)(candyMachine),
        version: src_1.AccountVersion.V2,
        tokenStandard: mpl_token_metadata_1.TokenStandard.ProgrammableNonFungible,
        ruleSet: (0, umi_1.some)(metaplexDefaultRuleSet),
    });
});
(0, ava_1.default)('it can create a candy machine with an explicit ruleset and hidden settings', async (t) => {
    // Given an existing collection NFT.
    const umi = await (0, _setup_1.createUmi)();
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    // When we create a new PNFT candy machine with hidden settings using an explicit rule set.
    const candyMachine = (0, umi_1.generateSigner)(umi);
    await (0, umi_1.transactionBuilder)()
        .add(await (0, src_1.createCandyMachineV2)(umi, {
        ...(0, _setup_1.defaultCandyMachineData)(umi),
        configLineSettings: (0, umi_1.none)(),
        hiddenSettings: (0, umi_1.some)({
            name: 'My NFT #$ID+1$',
            uri: 'https://example.com/$ID+1$.json',
            hash: new Uint8Array(Array(32).fill(42)),
        }),
        candyMachine,
        collectionMint,
        tokenStandard: mpl_token_metadata_1.TokenStandard.ProgrammableNonFungible,
        ruleSet: _setup_1.METAPLEX_DEFAULT_RULESET,
    }))
        .sendAndConfirm(umi);
    // Then we expect the candy machine account to store that information.
    const candyMachineAccount = await (0, src_1.fetchCandyMachine)(umi, candyMachine.publicKey);
    t.like(candyMachineAccount, {
        publicKey: (0, umi_1.publicKey)(candyMachine),
        version: src_1.AccountVersion.V2,
        tokenStandard: mpl_token_metadata_1.TokenStandard.ProgrammableNonFungible,
        ruleSet: (0, umi_1.some)(_setup_1.METAPLEX_DEFAULT_RULESET),
    });
});
//# sourceMappingURL=createCandyMachineV2.test.js.map