"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const umi_1 = require("@metaplex-foundation/umi");
const ava_1 = __importDefault(require("ava"));
const src_1 = require("../src");
const _setup_1 = require("./_setup");
(0, ava_1.default)('it can call the route instruction of a specific guard', async (t) => {
    // Given a candy machine with an allow list guard.
    const umi = await (0, _setup_1.createUmi)();
    const minter = (0, umi_1.generateSigner)(umi).publicKey;
    const allowedWallets = [
        minter,
        'Ur1CbWSGsXCdedknRbJsEk7urwAvu1uddmQv51nAnXB',
        'GjwcWFQYzemBtpUoN5fMAP2FZviTtMRWCmrppGuTthJS',
        '2vjCrmEFiN9CLLhiqy8u1JPh48av8Zpzp3kNkdTtirYG',
    ];
    const merkleRoot = (0, src_1.getMerkleRoot)(allowedWallets);
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        guards: { allowList: (0, umi_1.some)({ merkleRoot }) },
    });
    // When we call the route instruction of the allow list guard.
    const merkleProof = (0, src_1.getMerkleProof)(allowedWallets, minter);
    await (0, umi_1.transactionBuilder)()
        .add((0, src_1.route)(umi, {
        candyMachine,
        guard: 'allowList',
        routeArgs: { path: 'proof', merkleRoot, merkleProof, minter },
    }))
        .sendAndConfirm(umi);
    // Then the allow list proof PDA was created.
    const [allowListProofPda] = (0, src_1.findAllowListProofPda)(umi, {
        merkleRoot,
        user: minter,
        candyMachine,
        candyGuard: (0, src_1.findCandyGuardPda)(umi, { base: candyMachine })[0],
    });
    t.true(await umi.rpc.accountExists(allowListProofPda));
});
(0, ava_1.default)('it can call the route instruction of a specific guard on a group', async (t) => {
    // Given a Candy Machine with two allowList guards which supports the route instruction.
    const umi = await (0, _setup_1.createUmi)();
    const allowedWalletsA = [
        umi.identity.publicKey,
        'Ur1CbWSGsXCdedknRbJsEk7urwAvu1uddmQv51nAnXB',
    ];
    const allowedWalletsB = [
        'GjwcWFQYzemBtpUoN5fMAP2FZviTtMRWCmrppGuTthJS',
        '2vjCrmEFiN9CLLhiqy8u1JPh48av8Zpzp3kNkdTtirYG',
    ];
    const merkleRootA = (0, src_1.getMerkleRoot)(allowedWalletsA);
    const merkleRootB = (0, src_1.getMerkleRoot)(allowedWalletsB);
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        groups: [
            {
                label: 'GROUP1',
                guards: { allowList: (0, umi_1.some)({ merkleRoot: merkleRootA }) },
            },
            {
                label: 'GROUP2',
                guards: { allowList: (0, umi_1.some)({ merkleRoot: merkleRootB }) },
            },
        ],
    });
    // When we call the "proof" route of the guard in group 1.
    const merkleProofA = (0, src_1.getMerkleProof)(allowedWalletsA, umi.identity.publicKey);
    await (0, umi_1.transactionBuilder)()
        .add((0, src_1.route)(umi, {
        candyMachine,
        guard: 'allowList',
        group: (0, umi_1.some)('GROUP1'),
        routeArgs: {
            path: 'proof',
            merkleRoot: merkleRootA,
            merkleProof: merkleProofA,
        },
    }))
        .sendAndConfirm(umi);
    // Then the allow list proof PDA was created for group 1.
    const [allowListProofPdaA] = (0, src_1.findAllowListProofPda)(umi, {
        merkleRoot: merkleRootA,
        user: umi.identity.publicKey,
        candyMachine,
        candyGuard: (0, src_1.findCandyGuardPda)(umi, { base: candyMachine })[0],
    });
    t.true(await umi.rpc.accountExists(allowListProofPdaA));
    // But not for group 2.
    const [allowListProofPdaB] = (0, src_1.findAllowListProofPda)(umi, {
        merkleRoot: merkleRootB,
        user: umi.identity.publicKey,
        candyMachine,
        candyGuard: (0, src_1.findCandyGuardPda)(umi, { base: candyMachine })[0],
    });
    t.false(await umi.rpc.accountExists(allowListProofPdaB));
});
(0, ava_1.default)('it cannot call the route instruction of a guard that does not support it', async (t) => {
    // Given a candy machine with an bot tax guard which does not support the route instruction.
    const umi = await (0, _setup_1.createUmi)();
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        guards: { botTax: (0, umi_1.some)({ lamports: (0, umi_1.sol)(0.01), lastInstruction: true }) },
    });
    // When we try to call the route instruction of the bot tax guard.
    const promise = (0, umi_1.transactionBuilder)()
        .add((0, src_1.route)(umi, { candyMachine, guard: 'botTax', routeArgs: {} }))
        .sendAndConfirm(umi);
    // Then we expect a program error.
    await t.throwsAsync(promise, { message: /InstructionNotFound/ });
});
(0, ava_1.default)('it must provide a group label if the candy guard has groups', async (t) => {
    // Given a candy machine with an allow list guard in a group.
    const umi = await (0, _setup_1.createUmi)();
    const allowedWallets = [umi.identity.publicKey];
    const merkleRoot = (0, src_1.getMerkleRoot)(allowedWallets);
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        groups: [{ label: 'GROUP1', guards: { allowList: (0, umi_1.some)({ merkleRoot }) } }],
    });
    // When we try to call the route instruction without a group label.
    const merkleProof = (0, src_1.getMerkleProof)(allowedWallets, allowedWallets[0]);
    const promise = (0, umi_1.transactionBuilder)()
        .add((0, src_1.route)(umi, {
        candyMachine,
        guard: 'allowList',
        group: (0, umi_1.none)(),
        routeArgs: { path: 'proof', merkleRoot, merkleProof },
    }))
        .sendAndConfirm(umi);
    // Then we expect a program error.
    await t.throwsAsync(promise, { message: /RequiredGroupLabelNotFound/ });
});
(0, ava_1.default)('it must not provide a group label if the candy guard does not have groups', async (t) => {
    // Given a candy machine with an allow list guard and no groups.
    const umi = await (0, _setup_1.createUmi)();
    const allowedWallets = [umi.identity.publicKey];
    const merkleRoot = (0, src_1.getMerkleRoot)(allowedWallets);
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        guards: { allowList: (0, umi_1.some)({ merkleRoot }) },
    });
    // When we try to call the route instruction with a group label.
    const merkleProof = (0, src_1.getMerkleProof)(allowedWallets, allowedWallets[0]);
    const promise = (0, umi_1.transactionBuilder)()
        .add((0, src_1.route)(umi, {
        candyMachine,
        guard: 'allowList',
        group: (0, umi_1.some)('GROUPX'),
        routeArgs: { path: 'proof', merkleRoot, merkleProof },
    }))
        .sendAndConfirm(umi);
    // Then we expect a program error.
    await t.throwsAsync(promise, { message: /GroupNotFound/ });
});
(0, ava_1.default)('it can call the route instruction for guards associated with a candy machine v1', async (t) => {
    // Given a candy machine with an allow list guard.
    const umi = await (0, _setup_1.createUmi)();
    const allowedWallets = [
        umi.identity.publicKey,
        'Ur1CbWSGsXCdedknRbJsEk7urwAvu1uddmQv51nAnXB',
    ];
    const merkleRoot = (0, src_1.getMerkleRoot)(allowedWallets);
    const { publicKey: candyMachine } = await (0, _setup_1.createV1)(umi, {
        guards: { allowList: (0, umi_1.some)({ merkleRoot }) },
    });
    // When we call the route instruction of the allow list guard.
    const merkleProof = (0, src_1.getMerkleProof)(allowedWallets, umi.identity.publicKey);
    await (0, umi_1.transactionBuilder)()
        .add((0, src_1.route)(umi, {
        candyMachine,
        guard: 'allowList',
        routeArgs: { path: 'proof', merkleRoot, merkleProof },
    }))
        .sendAndConfirm(umi);
    // Then the allow list proof PDA was created.
    const [allowListProofPda] = (0, src_1.findAllowListProofPda)(umi, {
        merkleRoot,
        user: umi.identity.publicKey,
        candyMachine,
        candyGuard: (0, src_1.findCandyGuardPda)(umi, { base: candyMachine })[0],
    });
    t.true(await umi.rpc.accountExists(allowListProofPda));
});
//# sourceMappingURL=route.test.js.map