"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const mpl_toolbox_1 = require("@metaplex-foundation/mpl-toolbox");
const umi_1 = require("@metaplex-foundation/umi");
const umi_bundle_tests_1 = require("@metaplex-foundation/umi-bundle-tests");
const ava_1 = __importDefault(require("ava"));
const src_1 = require("../src");
const _setup_1 = require("./_setup");
(0, ava_1.default)('it can mint from a candy guard with no guards', async (t) => {
    // Given a candy machine with a candy guard that has no guards.
    const umi = await (0, _setup_1.createUmi)();
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const candyMachineSigner = await (0, _setup_1.createV1)(umi, {
        collectionMint,
        configLines: [{ name: 'Degen #1', uri: 'https://example.com/degen/1' }],
        guards: {},
        groups: [],
    });
    const candyMachine = candyMachineSigner.publicKey;
    // When we mint from the candy guard.
    const mint = (0, umi_1.generateSigner)(umi);
    const owner = (0, umi_1.generateSigner)(umi).publicKey;
    await (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.createMintWithAssociatedToken)(umi, { mint, owner, amount: 1 }))
        .add((0, src_1.mint)(umi, {
        candyMachine,
        nftMint: mint.publicKey,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
    }))
        .sendAndConfirm(umi);
    // Then the mint was successful.
    await (0, _setup_1.assertSuccessfulMint)(t, umi, { mint, owner, name: 'Degen #1' });
    // And the candy machine was updated.
    const candyMachineAccount = await (0, src_1.fetchCandyMachine)(umi, candyMachine);
    t.like(candyMachineAccount, { itemsRedeemed: 1n });
});
(0, ava_1.default)('it can mint from a candy guard with guards', async (t) => {
    // Given a candy machine with some guards.
    const umi = await (0, _setup_1.createUmi)();
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const destination = (0, umi_1.generateSigner)(umi).publicKey;
    const candyMachineSigner = await (0, _setup_1.createV1)(umi, {
        collectionMint,
        configLines: [{ name: 'Degen #1', uri: 'https://example.com/degen/1' }],
        guards: {
            botTax: { lamports: (0, umi_1.sol)(0.01), lastInstruction: true },
            solPayment: { lamports: (0, umi_1.sol)(2), destination },
        },
    });
    const candyMachine = candyMachineSigner.publicKey;
    // When we mint from the candy guard.
    const mint = (0, umi_1.generateSigner)(umi);
    const owner = (0, umi_1.generateSigner)(umi).publicKey;
    const payer = await (0, umi_bundle_tests_1.generateSignerWithSol)(umi, (0, umi_1.sol)(10));
    await (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.createMintWithAssociatedToken)(umi, { mint, owner, amount: 1 }))
        .add((0, src_1.mint)(umi, {
        candyMachine,
        nftMint: mint.publicKey,
        payer,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
        mintArgs: {
            solPayment: { destination },
        },
    }))
        .sendAndConfirm(umi);
    // Then the mint was successful.
    await (0, _setup_1.assertSuccessfulMint)(t, umi, { mint, owner, name: 'Degen #1' });
    // And the payer was charged.
    const payerBalance = await umi.rpc.getBalance(payer.publicKey);
    t.true((0, umi_1.isEqualToAmount)(payerBalance, (0, umi_1.sol)(8), (0, umi_1.sol)(0.02)));
    // And the candy machine was updated.
    const candyMachineAccount = await (0, src_1.fetchCandyMachine)(umi, candyMachine);
    t.like(candyMachineAccount, { itemsRedeemed: 1n });
});
(0, ava_1.default)('it can mint from a candy guard with groups', async (t) => {
    // Given a candy machine with guard groups.
    const umi = await (0, _setup_1.createUmi)();
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const destination = (0, umi_1.generateSigner)(umi).publicKey;
    const candyMachineSigner = await (0, _setup_1.createV1)(umi, {
        collectionMint,
        configLines: [{ name: 'Degen #1', uri: 'https://example.com/degen/1' }],
        guards: {
            botTax: { lamports: (0, umi_1.sol)(0.01), lastInstruction: true },
            solPayment: { lamports: (0, umi_1.sol)(2), destination },
        },
        groups: [
            { label: 'GROUP1', guards: { startDate: { date: (0, _setup_1.yesterday)() } } },
            { label: 'GROUP2', guards: { startDate: { date: (0, _setup_1.tomorrow)() } } },
        ],
    });
    const candyMachine = candyMachineSigner.publicKey;
    // When we mint from the candy guard.
    const mint = (0, umi_1.generateSigner)(umi);
    const owner = (0, umi_1.generateSigner)(umi).publicKey;
    await (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.createMintWithAssociatedToken)(umi, { mint, owner, amount: 1 }))
        .add((0, src_1.mint)(umi, {
        candyMachine,
        nftMint: mint.publicKey,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
        mintArgs: { solPayment: { destination } },
        group: 'GROUP1',
    }))
        .sendAndConfirm(umi);
    // Then the mint was successful.
    await (0, _setup_1.assertSuccessfulMint)(t, umi, { mint, owner, name: 'Degen #1' });
});
//# sourceMappingURL=mint.test.js.map