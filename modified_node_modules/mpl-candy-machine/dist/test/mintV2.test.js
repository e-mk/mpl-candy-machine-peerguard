"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable no-await-in-loop */
const mpl_token_metadata_1 = require("@metaplex-foundation/mpl-token-metadata");
const mpl_toolbox_1 = require("@metaplex-foundation/mpl-toolbox");
const umi_1 = require("@metaplex-foundation/umi");
const umi_bundle_tests_1 = require("@metaplex-foundation/umi-bundle-tests");
const ava_1 = __importDefault(require("ava"));
const src_1 = require("../src");
const _setup_1 = require("./_setup");
(0, ava_1.default)('it can mint from a candy guard with no guards', async (t) => {
    // Given a candy machine with a candy guard that has no guards.
    const umi = await (0, _setup_1.createUmi)();
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const candyMachineSigner = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        configLines: [{ name: 'Degen #1', uri: 'https://example.com/degen/1' }],
        guards: {},
        groups: [],
    });
    const candyMachine = candyMachineSigner.publicKey;
    // When we mint from the candy guard.
    const mint = (0, umi_1.generateSigner)(umi);
    const minter = (0, umi_1.generateSigner)(umi);
    await (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 600000 }))
        .add((0, src_1.mintV2)(umi, {
        candyMachine,
        minter,
        nftMint: mint,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
    }))
        .sendAndConfirm(umi);
    // Then the mint was successful.
    await (0, _setup_1.assertSuccessfulMint)(t, umi, { mint, owner: minter, name: 'Degen #1' });
    // And the candy machine was updated.
    const candyMachineAccount = await (0, src_1.fetchCandyMachine)(umi, candyMachine);
    t.like(candyMachineAccount, { itemsRedeemed: 1n });
});
(0, ava_1.default)('it can mint whilst creating the mint and token accounts beforehand', async (t) => {
    // Given a candy machine with a candy guard.
    const umi = await (0, _setup_1.createUmi)();
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const candyMachineSigner = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        configLines: [{ name: 'Degen #1', uri: 'https://example.com/degen/1' }],
        guards: {},
    });
    const candyMachine = candyMachineSigner.publicKey;
    // When we create a new mint and token account before minting.
    const mint = (0, umi_1.generateSigner)(umi);
    const minter = (0, umi_1.generateSigner)(umi);
    await (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.createMint)(umi, { mint }))
        .add((0, mpl_toolbox_1.createAssociatedToken)(umi, {
        mint: mint.publicKey,
        owner: minter.publicKey,
    }))
        .add((0, src_1.mintV2)(umi, {
        candyMachine,
        minter,
        nftMint: mint.publicKey,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
    }))
        .sendAndConfirm(umi);
    // Then the mint was successful.
    await (0, _setup_1.assertSuccessfulMint)(t, umi, { mint, owner: minter, name: 'Degen #1' });
    // And the candy machine was updated.
    const candyMachineAccount = await (0, src_1.fetchCandyMachine)(umi, candyMachine);
    t.like(candyMachineAccount, { itemsRedeemed: 1n });
});
(0, ava_1.default)('it can mint whilst creating only the mint account beforehand', async (t) => {
    // Given a candy machine with a candy guard.
    const umi = await (0, _setup_1.createUmi)();
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const candyMachineSigner = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        configLines: [{ name: 'Degen #1', uri: 'https://example.com/degen/1' }],
        guards: {},
    });
    const candyMachine = candyMachineSigner.publicKey;
    // When we create a new mint account before minting.
    const mint = (0, umi_1.generateSigner)(umi);
    const minter = (0, umi_1.generateSigner)(umi);
    await (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.createMint)(umi, { mint }))
        .add((0, src_1.mintV2)(umi, {
        candyMachine,
        minter,
        nftMint: mint.publicKey,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
    }))
        .sendAndConfirm(umi);
    // Then the mint was successful.
    await (0, _setup_1.assertSuccessfulMint)(t, umi, { mint, owner: minter, name: 'Degen #1' });
    // And the candy machine was updated.
    const candyMachineAccount = await (0, src_1.fetchCandyMachine)(umi, candyMachine);
    t.like(candyMachineAccount, { itemsRedeemed: 1n });
});
(0, ava_1.default)('it can mint to an explicit public key that is not the payer nor the minter', async (t) => {
    // Given a candy machine with a candy guard.
    const umi = await (0, _setup_1.createUmi)();
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const candyMachineSigner = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        configLines: [{ name: 'Degen #1', uri: 'https://example.com/degen/1' }],
        guards: {},
        tokenStandard: mpl_token_metadata_1.TokenStandard.ProgrammableNonFungible,
    });
    const candyMachine = candyMachineSigner.publicKey;
    // When we create a new mint and token account before minting
    // Using an explicit owner that is not the payer nor the minter.
    const mint = (0, umi_1.generateSigner)(umi);
    const minter = (0, umi_1.generateSigner)(umi);
    const owner = (0, umi_1.generateSigner)(umi).publicKey;
    await (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.createMintWithAssociatedToken)(umi, { mint, owner }))
        .add((0, src_1.mintV2)(umi, {
        candyMachine,
        minter,
        nftMint: mint.publicKey,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
        tokenStandard: mpl_token_metadata_1.TokenStandard.ProgrammableNonFungible,
        token: (0, mpl_toolbox_1.findAssociatedTokenPda)(umi, { mint: mint.publicKey, owner }),
    }))
        .sendAndConfirm(umi);
    // Then the mint was successful.
    await (0, _setup_1.assertSuccessfulMint)(t, umi, { mint, owner, name: 'Degen #1' });
});
(0, ava_1.default)('it can mint from a candy guard attached to a candy machine v1', async (t) => {
    // Given a candy machine v1 with a candy guard that has no guards.
    const umi = await (0, _setup_1.createUmi)();
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const candyMachineSigner = await (0, _setup_1.createV1)(umi, {
        collectionMint,
        configLines: [{ name: 'Degen #1', uri: 'https://example.com/degen/1' }],
        guards: {},
    });
    const candyMachine = candyMachineSigner.publicKey;
    // When we mint from it.
    const mint = (0, umi_1.generateSigner)(umi);
    const minter = (0, umi_1.generateSigner)(umi);
    await (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.createMintWithAssociatedToken)(umi, {
        mint,
        owner: minter.publicKey,
        amount: 1,
    }))
        .add((0, src_1.mintV2)(umi, {
        candyMachine,
        minter,
        nftMint: mint,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
        // We have to explicitly provide the collection authority record
        // because v2 defaults to the new way of deriving delegate records.
        collectionDelegateRecord: (0, mpl_token_metadata_1.findCollectionAuthorityRecordPda)(umi, {
            mint: collectionMint,
            collectionAuthority: (0, src_1.findCandyMachineAuthorityPda)(umi, {
                candyMachine,
            })[0],
        }),
    }))
        .sendAndConfirm(umi);
    // Then the mint was successful.
    await (0, _setup_1.assertSuccessfulMint)(t, umi, { mint, owner: minter, name: 'Degen #1' });
    // And the candy machine was updated.
    const candyMachineAccount = await (0, src_1.fetchCandyMachine)(umi, candyMachine);
    t.like(candyMachineAccount, { itemsRedeemed: 1n });
});
(0, ava_1.default)('it can mint from a candy guard with guards', async (t) => {
    // Given a candy machine with some guards.
    const umi = await (0, _setup_1.createUmi)();
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const destination = (0, umi_1.generateSigner)(umi).publicKey;
    const candyMachineSigner = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        configLines: [{ name: 'Degen #1', uri: 'https://example.com/degen/1' }],
        guards: {
            botTax: { lamports: (0, umi_1.sol)(0.01), lastInstruction: true },
            solPayment: { lamports: (0, umi_1.sol)(2), destination },
        },
    });
    const candyMachine = candyMachineSigner.publicKey;
    // When we mint from the candy guard.
    const mint = (0, umi_1.generateSigner)(umi);
    const minter = (0, umi_1.generateSigner)(umi);
    const payer = await (0, umi_bundle_tests_1.generateSignerWithSol)(umi, (0, umi_1.sol)(10));
    await (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 600000 }))
        .add((0, src_1.mintV2)(umi, {
        candyMachine,
        nftMint: mint,
        payer,
        minter,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
        mintArgs: {
            solPayment: { destination },
        },
    }))
        .sendAndConfirm(umi);
    // Then the mint was successful.
    await (0, _setup_1.assertSuccessfulMint)(t, umi, { mint, owner: minter, name: 'Degen #1' });
    // And the payer was charged.
    const payerBalance = await umi.rpc.getBalance(payer.publicKey);
    t.true((0, umi_1.isEqualToAmount)(payerBalance, (0, umi_1.sol)(8), (0, umi_1.sol)(0.1)));
    // And the candy machine was updated.
    const candyMachineAccount = await (0, src_1.fetchCandyMachine)(umi, candyMachine);
    t.like(candyMachineAccount, { itemsRedeemed: 1n });
});
(0, ava_1.default)('it can mint from a candy guard with groups', async (t) => {
    // Given a candy machine with guard groups.
    const umi = await (0, _setup_1.createUmi)();
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const destination = (0, umi_1.generateSigner)(umi).publicKey;
    const candyMachineSigner = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        configLines: [{ name: 'Degen #1', uri: 'https://example.com/degen/1' }],
        guards: {
            botTax: { lamports: (0, umi_1.sol)(0.01), lastInstruction: true },
            solPayment: { lamports: (0, umi_1.sol)(2), destination },
        },
        groups: [
            { label: 'GROUP1', guards: { startDate: { date: (0, _setup_1.yesterday)() } } },
            { label: 'GROUP2', guards: { startDate: { date: (0, _setup_1.tomorrow)() } } },
        ],
    });
    const candyMachine = candyMachineSigner.publicKey;
    // When we mint from it using GROUP1.
    const mint = (0, umi_1.generateSigner)(umi);
    const minter = (0, umi_1.generateSigner)(umi);
    await (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 600000 }))
        .add((0, src_1.mintV2)(umi, {
        candyMachine,
        nftMint: mint,
        minter,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
        mintArgs: { solPayment: { destination } },
        group: 'GROUP1',
    }))
        .sendAndConfirm(umi);
    // Then the mint was successful.
    await (0, _setup_1.assertSuccessfulMint)(t, umi, { mint, owner: minter });
});
(0, ava_1.default)('it cannot mint using the default guards if the candy guard has groups', async (t) => {
    // Given a candy machine with guard groups.
    const umi = await (0, _setup_1.createUmi)();
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const destination = (0, umi_1.generateSigner)(umi).publicKey;
    const candyMachineSigner = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        configLines: [{ name: 'Degen #1', uri: 'https://example.com/degen/1' }],
        guards: { solPayment: { lamports: (0, umi_1.sol)(2), destination } },
        groups: [
            { label: 'GROUP1', guards: { startDate: { date: (0, _setup_1.yesterday)() } } },
            { label: 'GROUP2', guards: { startDate: { date: (0, _setup_1.tomorrow)() } } },
        ],
    });
    const candyMachine = candyMachineSigner.publicKey;
    // When we try to mint using the default guards.
    const mint = (0, umi_1.generateSigner)(umi);
    const minter = (0, umi_1.generateSigner)(umi);
    const promise = (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 600000 }))
        .add((0, src_1.mintV2)(umi, {
        candyMachine,
        nftMint: mint,
        minter,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
        mintArgs: { solPayment: { destination } },
        group: (0, umi_1.none)(),
    }))
        .sendAndConfirm(umi);
    // Then we expect a program error.
    await t.throwsAsync(promise, { message: /RequiredGroupLabelNotFound/ });
});
(0, ava_1.default)('it cannot mint from a group if the provided group label does not exist', async (t) => {
    // Given a candy machine with no guard groups.
    const umi = await (0, _setup_1.createUmi)();
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const destination = (0, umi_1.generateSigner)(umi).publicKey;
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        configLines: [{ name: 'Degen #1', uri: 'https://example.com/degen/1' }],
        guards: { solPayment: { lamports: (0, umi_1.sol)(2), destination } },
        groups: [{ label: 'GROUP1', guards: { startDate: { date: (0, _setup_1.yesterday)() } } }],
    });
    // When we try to mint using a group that does not exist.
    const mint = (0, umi_1.generateSigner)(umi);
    const minter = (0, umi_1.generateSigner)(umi);
    const promise = (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 600000 }))
        .add((0, src_1.mintV2)(umi, {
        candyMachine,
        nftMint: mint,
        minter,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
        mintArgs: { solPayment: { destination } },
        group: 'GROUPX',
    }))
        .sendAndConfirm(umi);
    // Then we expect a program error.
    await t.throwsAsync(promise, { message: /GroupNotFound/ });
});
(0, ava_1.default)('it can mint using an explicit payer', async (t) => {
    // Given a candy machine with guards.
    const umi = await (0, _setup_1.createUmi)();
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const destination = (0, umi_1.generateSigner)(umi).publicKey;
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        configLines: [{ name: 'Degen #1', uri: 'https://example.com/degen/1' }],
        guards: { solPayment: { lamports: (0, umi_1.sol)(2), destination } },
    });
    // And an explicit payer with 10 SOL.
    const payer = await (0, umi_bundle_tests_1.generateSignerWithSol)(umi, (0, umi_1.sol)(10));
    // When we mint from it using that payer.
    const mint = (0, umi_1.generateSigner)(umi);
    const minter = (0, umi_1.generateSigner)(umi);
    await (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 600000 }))
        .add((0, src_1.mintV2)(umi, {
        candyMachine,
        minter,
        payer,
        nftMint: mint,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
        mintArgs: { solPayment: { destination } },
    }))
        .sendAndConfirm(umi);
    // Then the mint was successful.
    await (0, _setup_1.assertSuccessfulMint)(t, umi, { mint, owner: minter, name: 'Degen #1' });
    // And the payer was charged.
    const payerBalance = await umi.rpc.getBalance(payer.publicKey);
    t.true((0, umi_1.isEqualToAmount)(payerBalance, (0, umi_1.sol)(8), (0, umi_1.sol)(0.1)));
});
(0, ava_1.default)('it cannot mint from an empty candy machine', async (t) => {
    // Given an empty candy machine.
    const umi = await (0, _setup_1.createUmi)();
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        configLines: [],
        guards: {},
    });
    // When we try to mint from it.
    const mint = (0, umi_1.generateSigner)(umi);
    const minter = (0, umi_1.generateSigner)(umi);
    const promise = (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 600000 }))
        .add((0, src_1.mintV2)(umi, {
        candyMachine,
        nftMint: mint,
        minter,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
    }))
        .sendAndConfirm(umi);
    // Then we expect a program error.
    await t.throwsAsync(promise, { message: /CandyMachineEmpty/ });
});
(0, ava_1.default)('it cannot mint from a candy machine that is not fully loaded', async (t) => {
    // Given a candy machine that is 50% loaded.
    const umi = await (0, _setup_1.createUmi)();
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        itemsAvailable: 2,
        configLines: [{ name: 'Degen #1', uri: 'https://example.com/degen/1' }],
        guards: {},
    });
    // When we try to mint from it.
    const mint = (0, umi_1.generateSigner)(umi);
    const minter = (0, umi_1.generateSigner)(umi);
    const promise = (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 600000 }))
        .add((0, src_1.mintV2)(umi, {
        candyMachine,
        nftMint: mint,
        minter,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
    }))
        .sendAndConfirm(umi);
    // Then we expect a program error.
    await t.throwsAsync(promise, { message: /NotFullyLoaded/ });
});
(0, ava_1.default)('it cannot mint from a candy machine that has been fully minted', async (t) => {
    // Given a candy machine that has been fully minted.
    const umi = await (0, _setup_1.createUmi)();
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        configLines: [{ name: 'Degen #1', uri: 'https://example.com/degen/1' }],
        guards: {},
    });
    const mint = (0, umi_1.generateSigner)(umi);
    await (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 600000 }))
        .add((0, src_1.mintV2)(umi, {
        candyMachine,
        nftMint: mint,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
    }))
        .sendAndConfirm(umi);
    await (0, _setup_1.assertSuccessfulMint)(t, umi, { mint, owner: umi.identity });
    // When we try to mint from it again.
    const promise = (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 600000 }))
        .add((0, src_1.mintV2)(umi, {
        candyMachine,
        nftMint: (0, umi_1.generateSigner)(umi),
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
    }))
        .sendAndConfirm(umi);
    // Then we expect a program error.
    await t.throwsAsync(promise, { message: /CandyMachineEmpty/ });
});
(0, ava_1.default)('it can mint from a candy machine using hidden settings', async (t) => {
    // Given a candy machine with hidden settings.
    const umi = await (0, _setup_1.createUmi)();
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        itemsAvailable: 100,
        configLineSettings: (0, umi_1.none)(),
        hiddenSettings: {
            name: 'Degen #$ID+1$',
            uri: 'https://example.com/degen/$ID+1$',
            hash: new Uint8Array(32),
        },
        guards: {},
    });
    // When we mint from it.
    const mint = (0, umi_1.generateSigner)(umi);
    const minter = (0, umi_1.generateSigner)(umi);
    await (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 600000 }))
        .add((0, src_1.mintV2)(umi, {
        candyMachine,
        minter,
        nftMint: mint,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
    }))
        .sendAndConfirm(umi);
    // Then the mint was successful.
    await (0, _setup_1.assertSuccessfulMint)(t, umi, {
        mint,
        owner: minter,
        name: 'Degen #1',
        uri: 'https://example.com/degen/1',
    });
});
(0, ava_1.default)('it can mint from a candy machine sequentially', async (t) => {
    // Given a candy machine with sequential config line settings.
    const umi = await (0, _setup_1.createUmi)();
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const indices = Array.from({ length: 10 }, (x, i) => i + 1);
    const configLines = indices.map((index) => ({
        name: `${index}`,
        uri: `https://example.com/degen/${index}`,
    }));
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        configLines,
        configLineSettings: {
            prefixName: '',
            nameLength: 32,
            prefixUri: '',
            uriLength: 200,
            isSequential: true,
        },
        guards: {},
    });
    // When we mint from it.
    const minted = await drain(umi, candyMachine, collectionMint, indices.length);
    // Then the mints are sequential.
    t.deepEqual(indices, minted);
});
(0, ava_1.default)('it can mint from a candy machine in a random order', async (t) => {
    // Given a candy machine with non-sequential config line settings.
    const umi = await (0, _setup_1.createUmi)();
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const indices = Array.from({ length: 10 }, (x, i) => i + 1);
    const configLines = indices.map((index) => ({
        name: `${index}`,
        uri: `https://example.com/degen/${index}`,
    }));
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        configLines,
        configLineSettings: {
            prefixName: '',
            nameLength: 32,
            prefixUri: '',
            uriLength: 200,
            isSequential: false,
        },
        guards: {},
    });
    // When we mint from it.
    const minted = await drain(umi, candyMachine, collectionMint, indices.length);
    // Then the mints are not sequential.
    t.notDeepEqual(indices, minted);
    // And the mints are unique.
    minted.sort((a, b) => a - b);
    t.deepEqual(indices, minted);
});
(0, ava_1.default)('it can mint a programmable NFT', async (t) => {
    // Given a candy machine with a candy guard that mints PNFTs.
    const umi = await (0, _setup_1.createUmi)();
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        tokenStandard: mpl_token_metadata_1.TokenStandard.ProgrammableNonFungible,
        configLines: [{ name: 'Degen #1', uri: 'https://example.com/degen/1' }],
        guards: {},
    });
    // When we mint from it whilst specifying the token standard.
    const mint = (0, umi_1.generateSigner)(umi);
    const minter = (0, umi_1.generateSigner)(umi);
    await (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 600000 }))
        .add((0, src_1.mintV2)(umi, {
        candyMachine,
        minter,
        nftMint: mint,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
        tokenStandard: mpl_token_metadata_1.TokenStandard.ProgrammableNonFungible,
    }))
        .sendAndConfirm(umi);
    // Then the mint was successful.
    await (0, _setup_1.assertSuccessfulMint)(t, umi, {
        mint,
        owner: minter,
        tokenStandard: mpl_token_metadata_1.TokenStandard.ProgrammableNonFungible,
    });
    // And the candy machine was updated.
    const candyMachineAccount = await (0, src_1.fetchCandyMachine)(umi, candyMachine);
    t.like(candyMachineAccount, { itemsRedeemed: 1n });
});
const drain = async (umi, candyMachine, collectionMint, available) => {
    const indices = [];
    for (let i = 0; i < available; i += 1) {
        const mint = (0, umi_1.generateSigner)(umi);
        const minter = (0, umi_1.generateSigner)(umi);
        await (0, umi_1.transactionBuilder)()
            .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 600000 }))
            .add((0, src_1.mintV2)(umi, {
            candyMachine,
            minter,
            nftMint: mint,
            collectionMint,
            collectionUpdateAuthority: umi.identity.publicKey,
        }))
            .sendAndConfirm(umi);
        const asset = await (0, mpl_token_metadata_1.fetchDigitalAsset)(umi, mint.publicKey);
        indices.push(parseInt(asset.metadata.name, 10));
    }
    return indices;
};
//# sourceMappingURL=mintV2.test.js.map