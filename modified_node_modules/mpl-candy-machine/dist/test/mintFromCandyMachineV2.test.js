"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const mpl_toolbox_1 = require("@metaplex-foundation/mpl-toolbox");
const mpl_token_metadata_1 = require("@metaplex-foundation/mpl-token-metadata");
const umi_1 = require("@metaplex-foundation/umi");
const ava_1 = __importDefault(require("ava"));
const src_1 = require("../src");
const _setup_1 = require("./_setup");
(0, ava_1.default)('it can mint directly from a candy machine as the mint authority', async (t) => {
    // Given a loaded candy machine.
    const umi = await (0, _setup_1.createUmi)();
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const candyMachineSigner = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        configLines: [
            { name: 'Degen #1', uri: 'https://example.com/degen/1' },
            { name: 'Degen #2', uri: 'https://example.com/degen/2' },
        ],
    });
    const candyMachine = candyMachineSigner.publicKey;
    // When we mint a new NFT directly from the candy machine as the mint authority.
    const mint = (0, umi_1.generateSigner)(umi);
    const owner = (0, umi_1.generateSigner)(umi).publicKey;
    await (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 400000 }))
        .add((0, src_1.mintFromCandyMachineV2)(umi, {
        candyMachine,
        mintAuthority: umi.identity,
        nftOwner: owner,
        nftMint: mint,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
    }))
        .sendAndConfirm(umi);
    // Then the mint was successful.
    await (0, _setup_1.assertSuccessfulMint)(t, umi, { mint, owner });
    // And the candy machine was updated.
    const candyMachineAccount = await (0, src_1.fetchCandyMachine)(umi, candyMachine);
    t.like(candyMachineAccount, { itemsRedeemed: 1n });
});
(0, ava_1.default)('it can mint whilst creating the mint and token accounts beforehand', async (t) => {
    // Given a loaded candy machine.
    const umi = await (0, _setup_1.createUmi)();
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const candyMachineSigner = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        configLines: [
            { name: 'Degen #1', uri: 'https://example.com/degen/1' },
            { name: 'Degen #2', uri: 'https://example.com/degen/2' },
        ],
    });
    const candyMachine = candyMachineSigner.publicKey;
    // When we mint a new NFT directly from the candy machine as the mint authority.
    const mint = (0, umi_1.generateSigner)(umi);
    const owner = (0, umi_1.generateSigner)(umi).publicKey;
    await (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.createMint)(umi, { mint }))
        .add((0, mpl_toolbox_1.createAssociatedToken)(umi, { mint: mint.publicKey, owner }))
        .add((0, src_1.mintFromCandyMachineV2)(umi, {
        candyMachine,
        mintAuthority: umi.identity,
        nftOwner: owner,
        nftMint: mint.publicKey,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
    }))
        .sendAndConfirm(umi);
    // Then the mint was successful.
    await (0, _setup_1.assertSuccessfulMint)(t, umi, { mint, owner });
});
(0, ava_1.default)('it can mint whilst creating only the mint account beforehand', async (t) => {
    // Given a loaded candy machine.
    const umi = await (0, _setup_1.createUmi)();
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const candyMachineSigner = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        configLines: [
            { name: 'Degen #1', uri: 'https://example.com/degen/1' },
            { name: 'Degen #2', uri: 'https://example.com/degen/2' },
        ],
    });
    const candyMachine = candyMachineSigner.publicKey;
    // When we mint a new NFT directly from the candy machine as the mint authority.
    const mint = (0, umi_1.generateSigner)(umi);
    const owner = (0, umi_1.generateSigner)(umi).publicKey;
    await (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.createMint)(umi, { mint }))
        .add((0, src_1.mintFromCandyMachineV2)(umi, {
        candyMachine,
        mintAuthority: umi.identity,
        nftOwner: owner,
        nftMint: mint.publicKey,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
    }))
        .sendAndConfirm(umi);
    // Then the mint was successful.
    await (0, _setup_1.assertSuccessfulMint)(t, umi, { mint, owner });
});
(0, ava_1.default)('it cannot mint directly from a candy machine if we are not the mint authority', async (t) => {
    // Given a loaded candy machine with a mint authority A.
    const umi = await (0, _setup_1.createUmi)();
    const mintAuthorityA = (0, umi_1.generateSigner)(umi);
    const collectionMint = await (0, _setup_1.createCollectionNft)(umi, {
        authority: mintAuthorityA,
    });
    const candyMachineSigner = await (0, _setup_1.createV2)(umi, {
        authority: mintAuthorityA.publicKey,
        collectionMint: collectionMint.publicKey,
        collectionUpdateAuthority: mintAuthorityA,
        configLines: [
            { name: 'Degen #1', uri: 'https://example.com/degen/1' },
            { name: 'Degen #2', uri: 'https://example.com/degen/2' },
        ],
    });
    const candyMachine = candyMachineSigner.publicKey;
    // When we try to mint directly from the candy machine as mint authority B.
    const mintAuthorityB = (0, umi_1.generateSigner)(umi);
    const mint = (0, umi_1.generateSigner)(umi);
    const owner = (0, umi_1.generateSigner)(umi).publicKey;
    const promise = (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.createMintWithAssociatedToken)(umi, { mint, owner, amount: 1 }))
        .add((0, src_1.mintFromCandyMachineV2)(umi, {
        candyMachine,
        mintAuthority: mintAuthorityB,
        nftMint: mint.publicKey,
        nftOwner: owner,
        collectionMint: collectionMint.publicKey,
        collectionUpdateAuthority: umi.identity.publicKey,
    }))
        .sendAndConfirm(umi);
    // Then we expect a program error.
    await t.throwsAsync(promise, {
        message: /A has one constraint was violated/,
    });
    // And the candy machine stayed the same.
    const candyMachineAccount = await (0, src_1.fetchCandyMachine)(umi, candyMachine);
    t.like(candyMachineAccount, { itemsRedeemed: 0n });
});
(0, ava_1.default)('it can mint from a candy machine v1', async (t) => {
    // Given a loaded candy machine v1.
    const umi = await (0, _setup_1.createUmi)();
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const candyMachineSigner = await (0, _setup_1.createV1)(umi, {
        collectionMint,
        configLines: [
            { name: 'Degen #1', uri: 'https://example.com/degen/1' },
            { name: 'Degen #2', uri: 'https://example.com/degen/2' },
        ],
    });
    const candyMachine = candyMachineSigner.publicKey;
    // When mint from it directly usint the mint v2 instruction.
    const mint = (0, umi_1.generateSigner)(umi);
    const owner = (0, umi_1.generateSigner)(umi).publicKey;
    await (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.createMintWithAssociatedToken)(umi, { mint, owner, amount: 1 }))
        .add((0, src_1.mintFromCandyMachineV2)(umi, {
        candyMachine,
        mintAuthority: umi.identity,
        nftMint: mint.publicKey,
        nftOwner: owner,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
        // We have to explicitly provide the collection authority record
        // because v2 defaults to the new way of deriving delegate records.
        collectionDelegateRecord: (0, mpl_token_metadata_1.findCollectionAuthorityRecordPda)(umi, {
            mint: collectionMint,
            collectionAuthority: (0, src_1.findCandyMachineAuthorityPda)(umi, {
                candyMachine,
            })[0],
        }),
    }))
        .sendAndConfirm(umi);
    // Then the mint was successful.
    await (0, _setup_1.assertSuccessfulMint)(t, umi, { mint, owner });
});
//# sourceMappingURL=mintFromCandyMachineV2.test.js.map