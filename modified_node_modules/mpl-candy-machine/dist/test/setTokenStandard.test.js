"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const umi_1 = require("@metaplex-foundation/umi");
const ava_1 = __importDefault(require("ava"));
const mpl_token_metadata_1 = require("@metaplex-foundation/mpl-token-metadata");
const src_1 = require("../src");
const _setup_1 = require("./_setup");
(0, ava_1.default)('it can change token standard from NFT to pNFT', async (t) => {
    // Given a Candy Machine with NFT token standard.
    const umi = await (0, _setup_1.createUmi)();
    const collectionUpdateAuthority = (0, umi_1.generateSigner)(umi);
    const collection = await (0, _setup_1.createCollectionNft)(umi, {
        authority: collectionUpdateAuthority,
    });
    const candyMachine = await (0, _setup_1.createV1)(umi, {
        collectionMint: collection.publicKey,
        collectionUpdateAuthority,
    });
    // Then the Candy Machine's token standard is NFT.
    let candyMachineAccount = await (0, src_1.fetchCandyMachine)(umi, candyMachine.publicKey);
    t.like(candyMachineAccount, {
        tokenStandard: mpl_token_metadata_1.TokenStandard.NonFungible,
        version: src_1.AccountVersion.V1,
    });
    // When we update its token standard to pNFT
    await (0, umi_1.transactionBuilder)()
        .add((0, src_1.setTokenStandard)(umi, {
        candyMachine: candyMachine.publicKey,
        collectionMint: collection.publicKey,
        collectionUpdateAuthority,
        collectionAuthorityRecord: (0, mpl_token_metadata_1.findCollectionAuthorityRecordPda)(umi, {
            mint: collection.publicKey,
            collectionAuthority: (0, src_1.findCandyMachineAuthorityPda)(umi, {
                candyMachine: candyMachine.publicKey,
            })[0],
        }),
        tokenStandard: mpl_token_metadata_1.TokenStandard.ProgrammableNonFungible,
    }))
        .sendAndConfirm(umi);
    // Then the Candy Machine's token standard is pNFT.
    candyMachineAccount = await (0, src_1.fetchCandyMachine)(umi, candyMachine.publicKey);
    t.like(candyMachineAccount, {
        tokenStandard: mpl_token_metadata_1.TokenStandard.ProgrammableNonFungible,
        version: src_1.AccountVersion.V2,
    });
});
(0, ava_1.default)('it can change token standard from pNFT to NFT', async (t) => {
    // Given a Candy Machine with pNFT token standard.
    const umi = await (0, _setup_1.createUmi)();
    const collectionUpdateAuthority = (0, umi_1.generateSigner)(umi);
    const collection = await (0, _setup_1.createCollectionNft)(umi, {
        authority: collectionUpdateAuthority,
    });
    const candyMachine = await (0, _setup_1.createV2)(umi, {
        collectionMint: collection.publicKey,
        collectionUpdateAuthority,
        tokenStandard: mpl_token_metadata_1.TokenStandard.ProgrammableNonFungible,
    });
    // Then the Candy Machine's token standard is pNFT.
    let candyMachineAccount = await (0, src_1.fetchCandyMachine)(umi, candyMachine.publicKey);
    t.like(candyMachineAccount, {
        tokenStandard: mpl_token_metadata_1.TokenStandard.ProgrammableNonFungible,
        version: src_1.AccountVersion.V2,
    });
    // When we update its token standard to NFT
    await (0, umi_1.transactionBuilder)()
        .add((0, src_1.setTokenStandard)(umi, {
        candyMachine: candyMachine.publicKey,
        collectionMint: collection.publicKey,
        collectionUpdateAuthority,
        tokenStandard: mpl_token_metadata_1.TokenStandard.NonFungible,
    }))
        .sendAndConfirm(umi);
    // Then the Candy Machine's token standard is NFT.
    candyMachineAccount = await (0, src_1.fetchCandyMachine)(umi, candyMachine.publicKey);
    t.like(candyMachineAccount, {
        tokenStandard: mpl_token_metadata_1.TokenStandard.NonFungible,
        version: src_1.AccountVersion.V2,
    });
});
(0, ava_1.default)('it can change token standard from NFT to pNFT and then back to NFT', async (t) => {
    // Given a Candy Machine with NFT token standard.
    const umi = await (0, _setup_1.createUmi)();
    const collectionUpdateAuthority = (0, umi_1.generateSigner)(umi);
    const collection = await (0, _setup_1.createCollectionNft)(umi, {
        authority: collectionUpdateAuthority,
    });
    const candyMachine = await (0, _setup_1.createV1)(umi, {
        collectionMint: collection.publicKey,
        collectionUpdateAuthority,
    });
    // Then the Candy Machine's token standard is NFT.
    let candyMachineAccount = await (0, src_1.fetchCandyMachine)(umi, candyMachine.publicKey);
    t.like(candyMachineAccount, {
        tokenStandard: mpl_token_metadata_1.TokenStandard.NonFungible,
        version: src_1.AccountVersion.V1,
    });
    // When we update its token standard to pNFT
    await (0, umi_1.transactionBuilder)()
        .add((0, src_1.setTokenStandard)(umi, {
        candyMachine: candyMachine.publicKey,
        collectionMint: collection.publicKey,
        collectionUpdateAuthority,
        collectionAuthorityRecord: (0, mpl_token_metadata_1.findCollectionAuthorityRecordPda)(umi, {
            mint: collection.publicKey,
            collectionAuthority: (0, src_1.findCandyMachineAuthorityPda)(umi, {
                candyMachine: candyMachine.publicKey,
            })[0],
        }),
        tokenStandard: mpl_token_metadata_1.TokenStandard.ProgrammableNonFungible,
    }))
        .sendAndConfirm(umi);
    // Then the Candy Machine's token standard is pNFT.
    candyMachineAccount = await (0, src_1.fetchCandyMachine)(umi, candyMachine.publicKey);
    t.like(candyMachineAccount, {
        tokenStandard: mpl_token_metadata_1.TokenStandard.ProgrammableNonFungible,
        version: src_1.AccountVersion.V2,
    });
    // When we update its token standard to NFT
    await (0, umi_1.transactionBuilder)()
        .add((0, src_1.setTokenStandard)(umi, {
        candyMachine: candyMachine.publicKey,
        collectionMint: collection.publicKey,
        collectionUpdateAuthority,
        tokenStandard: mpl_token_metadata_1.TokenStandard.NonFungible,
    }))
        .sendAndConfirm(umi);
    // Then the Candy Machine's token standard is NFT.
    candyMachineAccount = await (0, src_1.fetchCandyMachine)(umi, candyMachine.publicKey);
    t.like(candyMachineAccount, {
        tokenStandard: mpl_token_metadata_1.TokenStandard.NonFungible,
        version: src_1.AccountVersion.V2,
    });
});
//# sourceMappingURL=setTokenStandard.test.js.map