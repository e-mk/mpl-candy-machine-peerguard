"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const mpl_token_metadata_1 = require("@metaplex-foundation/mpl-token-metadata");
const umi_1 = require("@metaplex-foundation/umi");
const ava_1 = __importDefault(require("ava"));
const src_1 = require("../src");
const _setup_1 = require("./_setup");
(0, ava_1.default)('it returns the ruleset stored on the candy machine if any', async (t) => {
    // Given an existing PNFT candy machine with a ruleset
    // such that its collection is a PNFT with no ruleset.
    const umi = await (0, _setup_1.createUmi)();
    const { publicKey: collectionMint } = await (0, _setup_1.createProgrammableNft)(umi, {
        ruleSet: (0, umi_1.none)(),
    });
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        tokenStandard: mpl_token_metadata_1.TokenStandard.ProgrammableNonFungible,
        ruleSet: _setup_1.METAPLEX_DEFAULT_RULESET,
    });
    // When we fetch the candy machine ruleset.
    const ruleSet = await (0, src_1.getCandyMachineRuleSet)(umi, candyMachine);
    // Then we expect the ruleset to be the one stored on the candy machine.
    t.deepEqual(ruleSet, (0, umi_1.some)(_setup_1.METAPLEX_DEFAULT_RULESET));
});
(0, ava_1.default)('it returns the ruleset stored on the collection PNFT if any', async (t) => {
    // Given an existing PNFT candy machine with no ruleset
    // such that its collection is a PNFT with a ruleset.
    const umi = await (0, _setup_1.createUmi)();
    const { publicKey: collectionMint } = await (0, _setup_1.createProgrammableNft)(umi, {
        ruleSet: (0, umi_1.some)(_setup_1.METAPLEX_DEFAULT_RULESET),
    });
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        tokenStandard: mpl_token_metadata_1.TokenStandard.ProgrammableNonFungible,
        ruleSet: undefined,
    });
    // When we fetch the candy machine ruleset.
    const ruleSet = await (0, src_1.getCandyMachineRuleSet)(umi, candyMachine);
    // Then we expect the ruleset to be the one stored on the collection.
    t.deepEqual(ruleSet, (0, umi_1.some)(_setup_1.METAPLEX_DEFAULT_RULESET));
});
(0, ava_1.default)('it returns the ruleset stored on the candy machine even if a ruleset is stored on the collection PNFT', async (t) => {
    // Given an existing PNFT candy machine with a ruleset
    // such that its collection is a PNFT also with a ruleset.
    const umi = await (0, _setup_1.createUmi)();
    const unusedRuleSet = (0, umi_1.generateSigner)(umi).publicKey;
    const { publicKey: collectionMint } = await (0, _setup_1.createProgrammableNft)(umi, {
        ruleSet: (0, umi_1.some)(unusedRuleSet),
    });
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        tokenStandard: mpl_token_metadata_1.TokenStandard.ProgrammableNonFungible,
        ruleSet: _setup_1.METAPLEX_DEFAULT_RULESET,
    });
    // When we fetch the candy machine ruleset.
    const ruleSet = await (0, src_1.getCandyMachineRuleSet)(umi, candyMachine);
    // Then we expect the ruleset to be the one stored on the candy machine.
    t.deepEqual(ruleSet, (0, umi_1.some)(_setup_1.METAPLEX_DEFAULT_RULESET));
});
(0, ava_1.default)('it returns none if the collection is a non-programmable NFT', async (t) => {
    // Given an existing candy machine with no ruleset.
    const umi = await (0, _setup_1.createUmi)();
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi);
    // When we fetch the candy machine ruleset.
    const ruleSet = await (0, src_1.getCandyMachineRuleSet)(umi, candyMachine);
    // Then we expect the ruleset to be none.
    t.true((0, umi_1.isNone)(ruleSet));
});
(0, ava_1.default)('it returns none if the collection is a programmable NFT with no ruleset', async (t) => {
    // Given an existing candy machine with a collection NFT that has no ruleset.
    const umi = await (0, _setup_1.createUmi)();
    const { publicKey: collectionMint } = await (0, _setup_1.createProgrammableNft)(umi, {
        ruleSet: (0, umi_1.none)(),
    });
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, { collectionMint });
    // When we fetch the candy machine ruleset.
    const ruleSet = await (0, src_1.getCandyMachineRuleSet)(umi, candyMachine);
    // Then we expect the ruleset to be none.
    t.true((0, umi_1.isNone)(ruleSet));
});
//# sourceMappingURL=getCandyMachineRuleSet.test.js.map