"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tomorrow = exports.yesterday = exports.assertBurnedNft = exports.assertBotTax = exports.assertSuccessfulMint = exports.createCandyGuard = exports.defaultCandyMachineData = exports.defaultAssetData = exports.createV2 = exports.createV1 = exports.createMintWithHolders = exports.createVerifiedProgrammableNft = exports.createVerifiedNft = exports.createCollectionNft = exports.createProgrammableNft = exports.createNft = exports.createUmi = exports.METAPLEX_DEFAULT_RULESET = void 0;
/* eslint-disable import/no-extraneous-dependencies */
const mpl_token_metadata_1 = require("@metaplex-foundation/mpl-token-metadata");
const mpl_toolbox_1 = require("@metaplex-foundation/mpl-toolbox");
const umi_1 = require("@metaplex-foundation/umi");
const umi_bundle_tests_1 = require("@metaplex-foundation/umi-bundle-tests");
const src_1 = require("../src");
exports.METAPLEX_DEFAULT_RULESET = (0, umi_1.publicKey)('eBJLFYPxJmMGKuFwpDWkzxZeUrad92kZRC5BJLpzyT9');
const createUmi = async () => (await (0, umi_bundle_tests_1.createUmi)()).use((0, src_1.mplCandyMachine)());
exports.createUmi = createUmi;
const createNft = async (umi, input = {}) => {
    const mint = (0, umi_1.generateSigner)(umi);
    await (0, mpl_token_metadata_1.createNft)(umi, {
        mint,
        ...(0, exports.defaultAssetData)(),
        ...input,
    }).sendAndConfirm(umi);
    return mint;
};
exports.createNft = createNft;
const createProgrammableNft = async (umi, input = {}) => {
    const mint = (0, umi_1.generateSigner)(umi);
    await (0, mpl_token_metadata_1.createProgrammableNft)(umi, {
        mint,
        ...(0, exports.defaultAssetData)(),
        ...input,
    }).sendAndConfirm(umi);
    return mint;
};
exports.createProgrammableNft = createProgrammableNft;
const createCollectionNft = async (umi, input = {}) => (0, exports.createNft)(umi, { ...input, isCollection: true });
exports.createCollectionNft = createCollectionNft;
const createVerifiedNft = async (umi, input) => {
    const { collectionMint, collectionAuthority = umi.identity, ...rest } = input;
    const mint = await (0, exports.createNft)(umi, {
        ...rest,
        collection: (0, umi_1.some)({ verified: false, key: collectionMint }),
    });
    const effectiveMint = (0, umi_1.publicKey)(rest.mint ?? mint.publicKey);
    await (0, umi_1.transactionBuilder)()
        .add((0, mpl_token_metadata_1.verifyCollectionV1)(umi, {
        authority: collectionAuthority,
        collectionMint,
        metadata: (0, mpl_token_metadata_1.findMetadataPda)(umi, { mint: effectiveMint })[0],
    }))
        .sendAndConfirm(umi);
    return mint;
};
exports.createVerifiedNft = createVerifiedNft;
const createVerifiedProgrammableNft = async (umi, input) => {
    const { collectionMint, collectionAuthority = umi.identity, ...rest } = input;
    const mint = await (0, exports.createProgrammableNft)(umi, {
        ...rest,
        collection: (0, umi_1.some)({ verified: false, key: collectionMint }),
    });
    const effectiveMint = (0, umi_1.publicKey)(rest.mint ?? mint.publicKey);
    await (0, umi_1.transactionBuilder)()
        .add((0, mpl_token_metadata_1.verifyCollectionV1)(umi, {
        authority: collectionAuthority,
        collectionMint,
        metadata: (0, mpl_token_metadata_1.findMetadataPda)(umi, { mint: effectiveMint })[0],
    }))
        .sendAndConfirm(umi);
    return mint;
};
exports.createVerifiedProgrammableNft = createVerifiedProgrammableNft;
const createMintWithHolders = async (umi, input) => {
    const atas = [];
    const mint = input.mint ?? (0, umi_1.generateSigner)(umi);
    const mintAuthority = input.mintAuthority ?? umi.identity;
    let builder = (0, umi_1.transactionBuilder)().add((0, mpl_toolbox_1.createMint)(umi, {
        ...input,
        mint,
        mintAuthority: mintAuthority.publicKey,
    }));
    input.holders.forEach((holder) => {
        const owner = (0, umi_1.publicKey)(holder.owner);
        const [token] = (0, mpl_toolbox_1.findAssociatedTokenPda)(umi, {
            mint: mint.publicKey,
            owner,
        });
        atas.push(token);
        builder = builder.add((0, mpl_toolbox_1.createAssociatedToken)(umi, { mint: mint.publicKey, owner }));
        if (holder.amount > 0) {
            builder = builder.add((0, mpl_toolbox_1.mintTokensTo)(umi, {
                mint: mint.publicKey,
                token,
                amount: holder.amount,
                mintAuthority,
            }));
        }
    });
    await builder.sendAndConfirm(umi);
    return [mint, ...atas];
};
exports.createMintWithHolders = createMintWithHolders;
const createV1 = async (umi, input = {}) => {
    const candyMachine = input.candyMachine ?? (0, umi_1.generateSigner)(umi);
    const collectionMint = input.collectionMint ?? (await (0, exports.createCollectionNft)(umi)).publicKey;
    let builder = (0, umi_1.transactionBuilder)().add(await (0, src_1.createCandyMachine)(umi, {
        ...(0, exports.defaultCandyMachineData)(umi),
        ...input,
        itemsAvailable: input.itemsAvailable ?? input.configLines?.length ?? 100,
        candyMachine,
        collectionMint,
    }));
    if (input.configLines !== undefined) {
        builder = builder.add((0, src_1.addConfigLines)(umi, {
            authority: input.collectionUpdateAuthority ?? umi.identity,
            candyMachine: candyMachine.publicKey,
            index: input.configLineIndex ?? 0,
            configLines: input.configLines,
        }));
    }
    if (input.guards !== undefined || input.groups !== undefined) {
        const candyGuard = (0, src_1.findCandyGuardPda)(umi, { base: candyMachine.publicKey });
        builder = builder
            .add((0, src_1.createCandyGuard)(umi, { ...input, base: candyMachine }))
            .add((0, src_1.wrap)(umi, { candyMachine: candyMachine.publicKey, candyGuard }));
    }
    await builder.sendAndConfirm(umi);
    return candyMachine;
};
exports.createV1 = createV1;
const createV2 = async (umi, input = {}) => {
    const candyMachine = input.candyMachine ?? (0, umi_1.generateSigner)(umi);
    const collectionMint = input.collectionMint ?? (await (0, exports.createCollectionNft)(umi)).publicKey;
    let builder = await (0, src_1.createCandyMachineV2)(umi, {
        ...(0, exports.defaultCandyMachineData)(umi),
        ...input,
        itemsAvailable: input.itemsAvailable ?? input.configLines?.length ?? 100,
        candyMachine,
        collectionMint,
    });
    if (input.configLines !== undefined) {
        builder = builder.add((0, src_1.addConfigLines)(umi, {
            authority: input.collectionUpdateAuthority ?? umi.identity,
            candyMachine: candyMachine.publicKey,
            index: input.configLineIndex ?? 0,
            configLines: input.configLines,
        }));
    }
    if (input.guards !== undefined || input.groups !== undefined) {
        const candyGuard = (0, src_1.findCandyGuardPda)(umi, { base: candyMachine.publicKey });
        builder = builder
            .add((0, src_1.createCandyGuard)(umi, { ...input, base: candyMachine }))
            .add((0, src_1.wrap)(umi, { candyMachine: candyMachine.publicKey, candyGuard }));
    }
    await builder.sendAndConfirm(umi);
    return candyMachine;
};
exports.createV2 = createV2;
const defaultAssetData = () => ({
    name: 'My Asset',
    sellerFeeBasisPoints: (0, umi_1.percentAmount)(10, 2),
    uri: 'https://example.com/my-asset.json',
});
exports.defaultAssetData = defaultAssetData;
const defaultCandyMachineData = (context) => ({
    tokenStandard: mpl_token_metadata_1.TokenStandard.NonFungible,
    collectionUpdateAuthority: context.identity,
    itemsAvailable: 100,
    sellerFeeBasisPoints: (0, umi_1.percentAmount)(10, 2),
    creators: [
        {
            address: context.identity.publicKey,
            verified: true,
            percentageShare: 100,
        },
    ],
    configLineSettings: (0, umi_1.some)({
        prefixName: '',
        nameLength: 32,
        prefixUri: '',
        uriLength: 200,
        isSequential: false,
    }),
});
exports.defaultCandyMachineData = defaultCandyMachineData;
const createCandyGuard = async (umi, input = {}) => {
    const base = input.base ?? (0, umi_1.generateSigner)(umi);
    await (0, umi_1.transactionBuilder)()
        .add((0, src_1.createCandyGuard)(umi, { ...input, base }))
        .sendAndConfirm(umi);
    return (0, src_1.findCandyGuardPda)(umi, { base: base.publicKey });
};
exports.createCandyGuard = createCandyGuard;
const assertSuccessfulMint = async (t, umi, input) => {
    const mint = (0, umi_1.publicKey)(input.mint);
    const owner = (0, umi_1.publicKey)(input.owner);
    const { token = (0, mpl_toolbox_1.findAssociatedTokenPda)(umi, { mint, owner }), tokenStandard, name, uri, } = input;
    // Nft.
    const nft = await (0, mpl_token_metadata_1.fetchDigitalAssetWithAssociatedToken)(umi, mint, owner);
    t.like(nft, {
        publicKey: (0, umi_1.publicKey)(mint),
        mint: {
            publicKey: (0, umi_1.publicKey)(mint),
            supply: 1n,
        },
        token: {
            publicKey: (0, umi_1.publicKey)(token),
            mint: (0, umi_1.publicKey)(mint),
            owner: (0, umi_1.publicKey)(owner),
            amount: 1n,
        },
        edition: {
            isOriginal: true,
        },
        metadata: {
            tokenStandard: { __option: 'Some' },
            primarySaleHappened: true,
        },
    });
    // Token Stardard.
    if (tokenStandard !== undefined) {
        t.deepEqual(nft.metadata.tokenStandard, (0, umi_1.some)(tokenStandard));
    }
    // Name.
    if (typeof name === 'string')
        t.is(nft.metadata.name, name);
    else if (name !== undefined)
        t.regex(nft.metadata.name, name);
    // Uri.
    if (typeof uri === 'string')
        t.is(nft.metadata.uri, uri);
    else if (uri !== undefined)
        t.regex(nft.metadata.uri, uri);
};
exports.assertSuccessfulMint = assertSuccessfulMint;
const assertBotTax = async (t, umi, mint, signature, extraRegex) => {
    const transaction = await umi.rpc.getTransaction(signature);
    t.true(transaction !== null);
    const logs = transaction.meta.logs.join('');
    t.regex(logs, /Candy Guard Botting is taxed/);
    if (extraRegex !== undefined)
        t.regex(logs, extraRegex);
    const [metadata] = (0, mpl_token_metadata_1.findMetadataPda)(umi, { mint: (0, umi_1.publicKey)(mint) });
    t.false(await umi.rpc.accountExists(metadata));
};
exports.assertBotTax = assertBotTax;
const assertBurnedNft = async (t, umi, mint, owner) => {
    owner = owner ?? umi.identity;
    const [tokenAccount] = (0, mpl_toolbox_1.findAssociatedTokenPda)(umi, {
        mint: (0, umi_1.publicKey)(mint),
        owner: (0, umi_1.publicKey)(owner),
    });
    const [metadataAccount] = (0, mpl_token_metadata_1.findMetadataPda)(umi, { mint: (0, umi_1.publicKey)(mint) });
    const [editionAccount] = (0, mpl_token_metadata_1.findMasterEditionPda)(umi, { mint: (0, umi_1.publicKey)(mint) });
    const metadata = await umi.rpc.getAccount(metadataAccount);
    // Metadata accounts is not closed since it contains fees but
    // the data length should be 1.
    t.true(metadata.exists);
    (0, umi_1.assertAccountExists)(metadata);
    t.true(metadata.data.length === 1);
    t.false(await umi.rpc.accountExists(tokenAccount));
    t.false(await umi.rpc.accountExists(editionAccount));
};
exports.assertBurnedNft = assertBurnedNft;
const yesterday = () => (0, umi_1.now)() - 3600n * 24n;
exports.yesterday = yesterday;
const tomorrow = () => (0, umi_1.now)() + 3600n * 24n;
exports.tomorrow = tomorrow;
//# sourceMappingURL=_setup.js.map