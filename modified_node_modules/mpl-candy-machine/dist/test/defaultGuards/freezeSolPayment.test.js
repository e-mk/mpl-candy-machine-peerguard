"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const mpl_toolbox_1 = require("@metaplex-foundation/mpl-toolbox");
const mpl_token_metadata_1 = require("@metaplex-foundation/mpl-token-metadata");
const umi_1 = require("@metaplex-foundation/umi");
const umi_bundle_tests_1 = require("@metaplex-foundation/umi-bundle-tests");
const ava_1 = __importDefault(require("ava"));
const src_1 = require("../../src");
const _setup_1 = require("../_setup");
(0, ava_1.default)('it transfers SOL to an escrow account and freezes the NFT', async (t) => {
    // Given a loaded Candy Machine with a freezeSolPayment guard.
    const umi = await (0, _setup_1.createUmi)();
    const destination = (0, umi_1.generateSigner)(umi).publicKey;
    const identityBalance = await umi.rpc.getBalance(umi.identity.publicKey);
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        configLines: [
            { name: 'Degen #1', uri: 'https://example.com/degen/1' },
            { name: 'Degen #2', uri: 'https://example.com/degen/2' },
        ],
        guards: {
            freezeSolPayment: (0, umi_1.some)({ lamports: (0, umi_1.sol)(1), destination }),
        },
    });
    // And given the freezeSolPayment guard is initialized.
    await (0, umi_1.transactionBuilder)()
        .add((0, src_1.route)(umi, {
        candyMachine,
        guard: 'freezeSolPayment',
        routeArgs: {
            path: 'initialize',
            period: 15 * 24 * 3600,
            candyGuardAuthority: umi.identity,
            destination,
        },
    }))
        .sendAndConfirm(umi);
    // When we mint from that candy machine.
    const mint = (0, umi_1.generateSigner)(umi);
    await (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 600000 }))
        .add((0, src_1.mintV2)(umi, {
        candyMachine,
        nftMint: mint,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
        mintArgs: { freezeSolPayment: (0, umi_1.some)({ destination }) },
    }))
        .sendAndConfirm(umi);
    // Then minting was successful.
    await (0, _setup_1.assertSuccessfulMint)(t, umi, { mint, owner: umi.identity });
    // And the NFT is frozen.
    const ata = (0, mpl_toolbox_1.findAssociatedTokenPda)(umi, {
        mint: mint.publicKey,
        owner: umi.identity.publicKey,
    });
    const tokenAccount = await (0, mpl_toolbox_1.fetchToken)(umi, ata);
    t.is(tokenAccount.state, mpl_toolbox_1.TokenState.Frozen);
    // And cannot be thawed since not all NFTs have been minted.
    const promise = thawNft(umi, candyMachine, destination, mint.publicKey);
    await t.throwsAsync(promise, { message: /ThawNotEnabled/ });
    // And the treasury escrow received SOLs.
    const [treasuryEscrow] = getFreezeEscrow(umi, candyMachine, destination);
    const treasuryEscrowBalance = await umi.rpc.getBalance(treasuryEscrow);
    t.true((0, umi_1.isEqualToAmount)(treasuryEscrowBalance, (0, umi_1.sol)(1), (0, umi_1.sol)(0.1)), 'treasury escrow received SOLs');
    // And was assigned the right data.
    const freezeEscrowAccount = await (0, src_1.fetchFreezeEscrow)(umi, treasuryEscrow);
    t.true((0, umi_1.isSome)(freezeEscrowAccount.firstMintTime));
    t.like(freezeEscrowAccount, {
        candyMachine: (0, umi_1.publicKey)(candyMachine),
        candyGuard: (0, umi_1.publicKey)((0, src_1.findCandyGuardPda)(umi, { base: candyMachine })),
        frozenCount: 1n,
        freezePeriod: BigInt(15 * 24 * 3600),
        destination: (0, umi_1.publicKey)(destination),
        authority: (0, umi_1.publicKey)(umi.identity),
    });
    // And the payer lost SOLs.
    const newIdentityBalance = await umi.rpc.getBalance(umi.identity.publicKey);
    t.true((0, umi_1.isEqualToAmount)(newIdentityBalance, (0, umi_1.subtractAmounts)(identityBalance, (0, umi_1.sol)(1)), (0, umi_1.sol)(0.1)));
});
(0, ava_1.default)('it allows minting even when the payer is different from the minter', async (t) => {
    // Given a loaded Candy Machine with a freezeSolPayment guard.
    const umi = await (0, _setup_1.createUmi)();
    const destination = (0, umi_1.generateSigner)(umi).publicKey;
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        configLines: [
            { name: 'Degen #1', uri: 'https://example.com/degen/1' },
            { name: 'Degen #2', uri: 'https://example.com/degen/2' },
        ],
        guards: {
            freezeSolPayment: (0, umi_1.some)({ lamports: (0, umi_1.sol)(1), destination }),
        },
    });
    // And given the freezeSolPayment guard is initialized.
    await initFreezeEscrow(umi, candyMachine, destination);
    // When we mint from that candy machine using an explicit minter.
    const mint = (0, umi_1.generateSigner)(umi);
    const minter = (0, umi_1.generateSigner)(umi);
    await (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 600000 }))
        .add((0, src_1.mintV2)(umi, {
        candyMachine,
        nftMint: mint,
        minter,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
        mintArgs: { freezeSolPayment: (0, umi_1.some)({ destination }) },
    }))
        .sendAndConfirm(umi);
    // Then minting was successful.
    await (0, _setup_1.assertSuccessfulMint)(t, umi, { mint, owner: minter });
});
(0, ava_1.default)('it allows minting when the mint and token accounts are created beforehand', async (t) => {
    // Given a loaded Candy Machine with a freezeSolPayment guard.
    const umi = await (0, _setup_1.createUmi)();
    const destination = (0, umi_1.generateSigner)(umi).publicKey;
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        configLines: [
            { name: 'Degen #1', uri: 'https://example.com/degen/1' },
            { name: 'Degen #2', uri: 'https://example.com/degen/2' },
        ],
        guards: {
            freezeSolPayment: (0, umi_1.some)({ lamports: (0, umi_1.sol)(1), destination }),
        },
    });
    // And given the freezeSolPayment guard is initialized.
    await initFreezeEscrow(umi, candyMachine, destination);
    // When we mint from that candy machine by creating
    // the mint and token accounts beforehand.
    const mint = (0, umi_1.generateSigner)(umi);
    await (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 600000 }))
        .add((0, mpl_toolbox_1.createMintWithAssociatedToken)(umi, {
        mint,
        owner: umi.identity.publicKey,
    }))
        .add((0, src_1.mintV2)(umi, {
        candyMachine,
        nftMint: mint.publicKey,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
        mintArgs: { freezeSolPayment: (0, umi_1.some)({ destination }) },
    }))
        .sendAndConfirm(umi);
    // Then minting was successful.
    await (0, _setup_1.assertSuccessfulMint)(t, umi, { mint, owner: umi.identity });
});
(0, ava_1.default)('it can thaw an NFT once all NFTs are minted', async (t) => {
    // Given a loaded Candy Machine with an initialized
    // freezeSolPayment guard with only one item.
    const umi = await (0, _setup_1.createUmi)();
    const destination = (0, umi_1.generateSigner)(umi).publicKey;
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        configLines: [{ name: 'Degen #1', uri: 'https://example.com/degen/1' }],
        guards: {
            freezeSolPayment: (0, umi_1.some)({ lamports: (0, umi_1.sol)(1), destination }),
        },
    });
    await initFreezeEscrow(umi, candyMachine, destination);
    // And given we minted the only frozen NFT from that candy machine.
    const mint = await mintNft(umi, candyMachine, destination, collectionMint);
    const token = (0, mpl_toolbox_1.findAssociatedTokenPda)(umi, {
        mint: mint.publicKey,
        owner: umi.identity.publicKey,
    });
    let tokenAccount = await (0, mpl_toolbox_1.fetchToken)(umi, token);
    t.is(tokenAccount.state, mpl_toolbox_1.TokenState.Frozen, 'NFT is frozen');
    // When we thaw the NFT.
    await thawNft(umi, candyMachine, destination, mint.publicKey);
    // Then the NFT is thawed.
    tokenAccount = await (0, mpl_toolbox_1.fetchToken)(umi, token);
    t.is(tokenAccount.state, mpl_toolbox_1.TokenState.Initialized, 'NFT is Thawed');
});
(0, ava_1.default)('it can unlock funds once all NFTs have been thawed', async (t) => {
    // Given a loaded Candy Machine with an initialized freezeSolPayment guard.
    const umi = await (0, _setup_1.createUmi)();
    const destination = (0, umi_1.generateSigner)(umi).publicKey;
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        configLines: [{ name: 'Degen #1', uri: 'https://example.com/degen/1' }],
        guards: {
            freezeSolPayment: (0, umi_1.some)({ lamports: (0, umi_1.sol)(1), destination }),
        },
    });
    await initFreezeEscrow(umi, candyMachine, destination);
    // And given all NFTs have been minted and thawed.
    const mint = await mintNft(umi, candyMachine, destination, collectionMint);
    await thawNft(umi, candyMachine, destination, mint.publicKey);
    // When the authority unlocks the funds.
    await (0, umi_1.transactionBuilder)()
        .add((0, src_1.route)(umi, {
        candyMachine,
        guard: 'freezeSolPayment',
        routeArgs: {
            path: 'unlockFunds',
            candyGuardAuthority: umi.identity,
            destination,
        },
    }))
        .sendAndConfirm(umi);
    // Then the destination wallet received the funds.
    const treasuryBalance = await umi.rpc.getBalance(destination);
    t.true((0, umi_1.isEqualToAmount)(treasuryBalance, (0, umi_1.sol)(1), (0, umi_1.sol)(0.1)), 'treasury received SOLs');
    // And the treasury escrow has been emptied.
    const [treasuryEscrow] = getFreezeEscrow(umi, candyMachine, destination);
    const treasuryEscrowBalance = await umi.rpc.getBalance(treasuryEscrow);
    t.true((0, umi_1.isEqualToAmount)(treasuryEscrowBalance, (0, umi_1.sol)(0)), 'treasury escrow received SOLs');
});
(0, ava_1.default)('it cannot unlock funds if not all NFTs have been thawed', async (t) => {
    // Given a loaded Candy Machine with an initialized freezeSolPayment guard.
    const umi = await (0, _setup_1.createUmi)();
    const destination = (0, umi_1.generateSigner)(umi).publicKey;
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        configLines: [{ name: 'Degen #1', uri: 'https://example.com/degen/1' }],
        guards: {
            freezeSolPayment: (0, umi_1.some)({ lamports: (0, umi_1.sol)(1), destination }),
        },
    });
    await initFreezeEscrow(umi, candyMachine, destination);
    // And given all NFTs have been minted but not thawed.
    await mintNft(umi, candyMachine, destination, collectionMint);
    // When the authority tries to unlock the funds.
    const promise = (0, umi_1.transactionBuilder)()
        .add((0, src_1.route)(umi, {
        candyMachine,
        guard: 'freezeSolPayment',
        routeArgs: {
            path: 'unlockFunds',
            candyGuardAuthority: umi.identity,
            destination,
        },
    }))
        .sendAndConfirm(umi);
    // Then we expect an error.
    await t.throwsAsync(promise, { message: /UnlockNotEnabled/ });
    // And the destination wallet did not receive any funds.
    const treasuryBalance = await umi.rpc.getBalance(destination);
    t.true((0, umi_1.isEqualToAmount)(treasuryBalance, (0, umi_1.sol)(0)), 'treasury received no SOLs');
});
(0, ava_1.default)('it can have multiple freeze escrow and reuse the same ones', async (t) => {
    // Increase the timeout of this long test to 20 seconds.
    t.timeout(20000);
    // Given a loaded Candy Machine with 4 groups
    // containing freezeSolPayment guards such that:
    // - Group A and Group B use the same destination (and thus freeze escrow).
    // - Group C uses a different destination than group A and B.
    // - Group D does not use a freezeSolPayment guard at all.
    const umi = await (0, _setup_1.createUmi)();
    const identityBalance = await umi.rpc.getBalance(umi.identity.publicKey);
    const destinationAB = (0, umi_1.generateSigner)(umi).publicKey;
    const destinationC = (0, umi_1.generateSigner)(umi).publicKey;
    const destinationD = (0, umi_1.generateSigner)(umi).publicKey;
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        configLines: [
            { name: 'Degen #1', uri: 'https://example.com/degen/1' },
            { name: 'Degen #2', uri: 'https://example.com/degen/2' },
            { name: 'Degen #3', uri: 'https://example.com/degen/3' },
            { name: 'Degen #4', uri: 'https://example.com/degen/4' },
        ],
        guards: {},
        groups: [
            {
                label: 'GROUPA',
                guards: {
                    freezeSolPayment: (0, umi_1.some)({
                        lamports: (0, umi_1.sol)(0.5),
                        destination: destinationAB,
                    }),
                },
            },
            {
                label: 'GROUPB',
                guards: {
                    freezeSolPayment: (0, umi_1.some)({
                        lamports: (0, umi_1.sol)(1),
                        destination: destinationAB,
                    }),
                },
            },
            {
                label: 'GROUPC',
                guards: {
                    freezeSolPayment: (0, umi_1.some)({
                        lamports: (0, umi_1.sol)(2),
                        destination: destinationC,
                    }),
                },
            },
            {
                label: 'GROUPD',
                guards: {
                    solPayment: (0, umi_1.some)({ lamports: (0, umi_1.sol)(3), destination: destinationD }),
                },
            },
        ],
    });
    // And given all freeze escrows have been initialized.
    await initFreezeEscrow(umi, candyMachine, destinationAB, 'GROUPA');
    await initFreezeEscrow(umi, candyMachine, destinationC, 'GROUPC');
    // Note that trying to initialize the escrow for group B will fail
    // because it has already been initialized via group A.
    await t.throwsAsync(initFreezeEscrow(umi, candyMachine, destinationAB, 'GROUPB'), { message: /The freeze escrow account already exists/ });
    // When we mint all 4 NFTs via each group.
    const cm = candyMachine;
    const mintA = await mintNft(umi, cm, destinationAB, collectionMint, 'GROUPA'); // 0.5 SOL
    const mintB = await mintNft(umi, cm, destinationAB, collectionMint, 'GROUPB'); // 1 SOL
    const mintC = await mintNft(umi, cm, destinationC, collectionMint, 'GROUPC'); // 2 SOL
    const mintD = (0, umi_1.generateSigner)(umi); // 3 SOL
    await (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 600000 }))
        .add((0, src_1.mintV2)(umi, {
        candyMachine,
        nftMint: mintD,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
        group: (0, umi_1.some)('GROUPD'),
        mintArgs: {
            solPayment: (0, umi_1.some)({ destination: destinationD }),
        },
    }))
        .sendAndConfirm(umi);
    // Then all NFTs except for group D have been frozen.
    const [tokenA, tokenB, tokenC, tokenD] = await Promise.all([mintA, mintB, mintC, mintD].map(({ publicKey: mint }) => (0, mpl_toolbox_1.fetchToken)(umi, (0, mpl_toolbox_1.findAssociatedTokenPda)(umi, { mint, owner: umi.identity.publicKey }))));
    t.is(tokenA.state, mpl_toolbox_1.TokenState.Frozen, 'NFT A is frozen');
    t.is(tokenB.state, mpl_toolbox_1.TokenState.Frozen, 'NFT B is frozen');
    t.is(tokenC.state, mpl_toolbox_1.TokenState.Frozen, 'NFT C is frozen');
    t.is(tokenD.state, mpl_toolbox_1.TokenState.Initialized, 'NFT D is not frozen');
    // And the treasury escrow received SOLs.
    const [treasuryEscrowAB] = getFreezeEscrow(umi, candyMachine, destinationAB);
    const [treasuryEscrowC] = getFreezeEscrow(umi, candyMachine, destinationC);
    const treasuryEscrowBalanceAB = await umi.rpc.getBalance(treasuryEscrowAB);
    const treasuryEscrowBalanceC = await umi.rpc.getBalance(treasuryEscrowC);
    t.true((0, umi_1.isEqualToAmount)(treasuryEscrowBalanceAB, (0, umi_1.sol)(1.5), (0, umi_1.sol)(0.1)), 'treasury AB escrow received SOLs');
    t.true((0, umi_1.isEqualToAmount)(treasuryEscrowBalanceC, (0, umi_1.sol)(2), (0, umi_1.sol)(0.1)), 'treasury C escrow received SOLs');
    // And the identity lost SOLs.
    const newIdentityBalance = await umi.rpc.getBalance(umi.identity.publicKey);
    t.true((0, umi_1.isEqualToAmount)(newIdentityBalance, (0, umi_1.subtractAmounts)(identityBalance, (0, umi_1.sol)(6.5)), (0, umi_1.sol)(0.2)), 'identity lost SOLs');
    // And the frozen counters securely decrease as we thaw all frozen NFTs.
    const assertFrozenCounts = async (ab, c) => {
        await Promise.all([
            assertFrozenCount(t, umi, candyMachine, destinationAB, ab),
            assertFrozenCount(t, umi, candyMachine, destinationC, c),
        ]);
    };
    await assertFrozenCounts(2, 1);
    await thawNft(umi, cm, destinationAB, mintD.publicKey, 'GROUPA'); // Not frozen.
    await assertFrozenCounts(2, 1); // No change.
    await thawNft(umi, cm, destinationAB, mintA.publicKey, 'GROUPA');
    await assertFrozenCounts(1, 1); // AB decreased.
    await thawNft(umi, cm, destinationAB, mintA.publicKey, 'GROUPA'); // Already thawed.
    await assertFrozenCounts(1, 1); // No change.
    await thawNft(umi, cm, destinationAB, mintB.publicKey, 'GROUPB');
    await assertFrozenCounts(0, 1); // AB decreased.
    await thawNft(umi, cm, destinationC, mintC.publicKey, 'GROUPC');
    await assertFrozenCounts(0, 0); // C decreased.
    // And when the authority unlocks the funds of both freeze escrows.
    await unlockFunds(umi, cm, destinationAB, 'GROUPA');
    await unlockFunds(umi, cm, destinationC, 'GROUPC');
    // Note that trying to unlock the funds of group B will fail
    // because it has already been unlocked via group A.
    await t.throwsAsync(unlockFunds(umi, candyMachine, destinationAB, 'GROUPB'), {
        message: /AccountNotInitialized/,
    });
    // Then the treasuries received the funds.
    const [treasuryBalanceAB, treasuryBalanceC, treasuryBalanceD] = await Promise.all([
        umi.rpc.getBalance(destinationAB),
        umi.rpc.getBalance(destinationC),
        umi.rpc.getBalance(destinationD),
    ]);
    t.true((0, umi_1.isEqualToAmount)(treasuryBalanceAB, (0, umi_1.sol)(1.5), (0, umi_1.sol)(0.1)), 'treasury AB received the funds');
    t.true((0, umi_1.isEqualToAmount)(treasuryBalanceC, (0, umi_1.sol)(2), (0, umi_1.sol)(0.1)), 'treasury C  received the funds');
    t.true((0, umi_1.isEqualToAmount)(treasuryBalanceD, (0, umi_1.sol)(3), (0, umi_1.sol)(0.1)), 'treasury D  received the funds');
    // And the treasury escrows are empty.
    const [newEscrowBalanceAB, newEscrowBalanceC] = await Promise.all([
        umi.rpc.getBalance(treasuryEscrowAB),
        await umi.rpc.getBalance(treasuryEscrowC),
    ]);
    t.true((0, umi_1.isEqualToAmount)(newEscrowBalanceAB, (0, umi_1.sol)(0)), 'treasury AB escrow is empty');
    t.true((0, umi_1.isEqualToAmount)(newEscrowBalanceC, (0, umi_1.sol)(0)), 'treasury C escrow is empty');
});
(0, ava_1.default)('it fails to mint if the freeze escrow was not initialized', async (t) => {
    // Given a loaded Candy Machine with a freezeSolPayment guard.
    const umi = await (0, _setup_1.createUmi)();
    const destination = (0, umi_1.generateSigner)(umi).publicKey;
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        configLines: [{ name: 'Degen #1', uri: 'https://example.com/degen/1' }],
        guards: {
            freezeSolPayment: (0, umi_1.some)({ lamports: (0, umi_1.sol)(1), destination }),
        },
    });
    // When we try to mint without initializing the freeze escrow.
    const mint = (0, umi_1.generateSigner)(umi);
    const promise = (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 600000 }))
        .add((0, src_1.mintV2)(umi, {
        candyMachine,
        nftMint: mint,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
        mintArgs: { freezeSolPayment: (0, umi_1.some)({ destination }) },
    }))
        .sendAndConfirm(umi);
    // Then we expect an error.
    await t.throwsAsync(promise, { message: /FreezeNotInitialized/ });
});
(0, ava_1.default)('it fails to mint if the payer does not have enough funds', async (t) => {
    // Given a loaded Candy Machine with an initialized
    // freezeSolPayment guard costing 5 SOLs.
    const umi = await (0, _setup_1.createUmi)();
    const destination = (0, umi_1.generateSigner)(umi).publicKey;
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        configLines: [{ name: 'Degen #1', uri: 'https://example.com/degen/1' }],
        guards: {
            freezeSolPayment: (0, umi_1.some)({ lamports: (0, umi_1.sol)(5), destination }),
        },
    });
    await initFreezeEscrow(umi, candyMachine, destination);
    // When we mint from it using a payer that only has 4 SOL.
    const payer = await (0, umi_bundle_tests_1.generateSignerWithSol)(umi, (0, umi_1.sol)(4));
    const mint = (0, umi_1.generateSigner)(umi);
    const promise = (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 600000 }))
        .add((0, src_1.mintV2)(umi, {
        candyMachine,
        nftMint: mint,
        payer,
        minter: payer,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
        mintArgs: { freezeSolPayment: (0, umi_1.some)({ destination }) },
    }))
        .sendAndConfirm(umi);
    // Then we expect an error.
    await t.throwsAsync(promise, { message: /NotEnoughSOL/ });
    // And the payer didn't loose any SOL.
    const payerBalance = await umi.rpc.getBalance(payer.publicKey);
    t.true((0, umi_1.isEqualToAmount)(payerBalance, (0, umi_1.sol)(4)), 'payer did not lose SOLs');
});
(0, ava_1.default)('it charges a bot tax if something goes wrong', async (t) => {
    // Given a loaded Candy Machine with a freezeSolPayment guard and a botTax guard.
    const umi = await (0, _setup_1.createUmi)();
    const destination = (0, umi_1.generateSigner)(umi).publicKey;
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        configLines: [{ name: 'Degen #1', uri: 'https://example.com/degen/1' }],
        guards: {
            botTax: (0, umi_1.some)({ lamports: (0, umi_1.sol)(0.1), lastInstruction: true }),
            freezeSolPayment: (0, umi_1.some)({ lamports: (0, umi_1.sol)(1), destination }),
        },
    });
    // When we try to mint without initializing the freeze escrow.
    const mint = (0, umi_1.generateSigner)(umi);
    const { signature } = await (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 600000 }))
        .add((0, src_1.mintV2)(umi, {
        candyMachine,
        nftMint: mint,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
        mintArgs: { freezeSolPayment: (0, umi_1.some)({ destination }) },
    }))
        .sendAndConfirm(umi);
    // Then we expect a bot tax error.
    await (0, _setup_1.assertBotTax)(t, umi, mint, signature, /FreezeNotInitialized/);
});
(0, ava_1.default)('it transfers SOL to an escrow account and locks the Programmable NFT', async (t) => {
    // Given a loaded Candy Machine with a freezeSolPayment guard.
    const umi = await (0, _setup_1.createUmi)();
    const destination = (0, umi_1.generateSigner)(umi).publicKey;
    const identityBalance = await umi.rpc.getBalance(umi.identity.publicKey);
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        tokenStandard: mpl_token_metadata_1.TokenStandard.ProgrammableNonFungible,
        ruleSet: _setup_1.METAPLEX_DEFAULT_RULESET,
        collectionMint,
        configLines: [
            { name: 'Degen #1', uri: 'https://example.com/degen/1' },
            { name: 'Degen #2', uri: 'https://example.com/degen/2' },
        ],
        guards: {
            freezeSolPayment: (0, umi_1.some)({ lamports: (0, umi_1.sol)(1), destination }),
        },
    });
    // And given the freezeSolPayment guard is initialized.
    await initFreezeEscrow(umi, candyMachine, destination);
    // When we mint from that candy machine.
    const mint = (0, umi_1.generateSigner)(umi);
    await (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 800000 }))
        .add((0, src_1.mintV2)(umi, {
        candyMachine,
        nftMint: mint,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
        mintArgs: {
            freezeSolPayment: (0, umi_1.some)({
                destination,
                nftRuleSet: _setup_1.METAPLEX_DEFAULT_RULESET,
            }),
        },
        tokenStandard: mpl_token_metadata_1.TokenStandard.ProgrammableNonFungible,
        authorizationRulesProgram: (0, src_1.getMplTokenAuthRulesProgramId)(umi),
    }))
        .sendAndConfirm(umi);
    // Then minting was successful.
    await (0, _setup_1.assertSuccessfulMint)(t, umi, { mint, owner: umi.identity });
    // And the pNFT is frozen.
    const [ata] = (0, mpl_toolbox_1.findAssociatedTokenPda)(umi, {
        mint: mint.publicKey,
        owner: umi.identity.publicKey,
    });
    const tokenAccount = await (0, mpl_toolbox_1.fetchToken)(umi, ata);
    t.is(tokenAccount.state, mpl_toolbox_1.TokenState.Frozen);
    // And the token record is locked.
    const [tokenRecord] = (0, mpl_token_metadata_1.findTokenRecordPda)(umi, {
        mint: mint.publicKey,
        token: ata,
    });
    const tokenRecodAccount = await (0, mpl_token_metadata_1.fetchTokenRecord)(umi, tokenRecord);
    t.is(tokenRecodAccount.state, mpl_token_metadata_1.TokenState.Locked);
    // And cannot be thawed since not all NFTs have been minted.
    const promise = thawNft(umi, candyMachine, destination, mint.publicKey);
    await t.throwsAsync(promise, { message: /ThawNotEnabled/ });
    // And the treasury escrow received SOLs.
    const [treasuryEscrow] = getFreezeEscrow(umi, candyMachine, destination);
    const treasuryEscrowBalance = await umi.rpc.getBalance(treasuryEscrow);
    t.true((0, umi_1.isEqualToAmount)(treasuryEscrowBalance, (0, umi_1.sol)(1), (0, umi_1.sol)(0.1)), 'treasury escrow received SOLs');
    // And was assigned the right data.
    const freezeEscrowAccount = await (0, src_1.fetchFreezeEscrow)(umi, treasuryEscrow);
    t.true((0, umi_1.isSome)(freezeEscrowAccount.firstMintTime));
    t.like(freezeEscrowAccount, {
        candyMachine: (0, umi_1.publicKey)(candyMachine),
        candyGuard: (0, umi_1.publicKey)((0, src_1.findCandyGuardPda)(umi, { base: candyMachine })),
        frozenCount: 1n,
        freezePeriod: BigInt(15 * 24 * 3600),
        destination: (0, umi_1.publicKey)(destination),
        authority: (0, umi_1.publicKey)(umi.identity),
    });
    // And the payer lost SOLs.
    const newIdentityBalance = await umi.rpc.getBalance(umi.identity.publicKey);
    t.true((0, umi_1.isEqualToAmount)(newIdentityBalance, (0, umi_1.subtractAmounts)(identityBalance, (0, umi_1.sol)(1)), (0, umi_1.sol)(0.1)));
});
(0, ava_1.default)('it can thaw a Programmable NFT once all NFTs are minted', async (t) => {
    // Given a loaded Candy Machine with a ruleSet and an initialized
    // freezeSolPayment guard with only one item.
    const umi = await (0, _setup_1.createUmi)();
    const destination = (0, umi_1.generateSigner)(umi).publicKey;
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        tokenStandard: mpl_token_metadata_1.TokenStandard.ProgrammableNonFungible,
        ruleSet: _setup_1.METAPLEX_DEFAULT_RULESET,
        configLines: [{ name: 'Degen #1', uri: 'https://example.com/degen/1' }],
        guards: {
            freezeSolPayment: (0, umi_1.some)({ lamports: (0, umi_1.sol)(1), destination }),
        },
    });
    await initFreezeEscrow(umi, candyMachine, destination);
    // And given we minted the only PNFT from that candy machine.
    const mint = (0, umi_1.generateSigner)(umi);
    await (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 800000 }))
        .add((0, src_1.mintV2)(umi, {
        candyMachine,
        nftMint: mint,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
        mintArgs: {
            freezeSolPayment: (0, umi_1.some)({
                destination,
                nftRuleSet: _setup_1.METAPLEX_DEFAULT_RULESET,
            }),
        },
        tokenStandard: mpl_token_metadata_1.TokenStandard.ProgrammableNonFungible,
        authorizationRulesProgram: (0, src_1.getMplTokenAuthRulesProgramId)(umi),
    }))
        .sendAndConfirm(umi);
    // And that is it locked.
    const [tokenRecord] = (0, mpl_token_metadata_1.findTokenRecordPda)(umi, {
        mint: mint.publicKey,
        token: (0, mpl_toolbox_1.findAssociatedTokenPda)(umi, {
            mint: mint.publicKey,
            owner: umi.identity.publicKey,
        })[0],
    });
    let tokenRecordAccount = await (0, mpl_token_metadata_1.fetchTokenRecord)(umi, tokenRecord);
    t.is(tokenRecordAccount.state, mpl_token_metadata_1.TokenState.Locked);
    // When we thaw the locked PNFT.
    await (0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 600000 })
        .add((0, src_1.route)(umi, {
        candyMachine,
        guard: 'freezeSolPayment',
        routeArgs: {
            path: 'thaw',
            nftMint: mint.publicKey,
            nftOwner: umi.identity.publicKey,
            nftTokenStandard: mpl_token_metadata_1.TokenStandard.ProgrammableNonFungible,
            destination,
            nftRuleSet: _setup_1.METAPLEX_DEFAULT_RULESET,
        },
    }))
        .sendAndConfirm(umi);
    // Then the PNFT is unlocked.
    tokenRecordAccount = await (0, mpl_token_metadata_1.fetchTokenRecord)(umi, tokenRecord);
    t.is(tokenRecordAccount.state, mpl_token_metadata_1.TokenState.Unlocked);
    // And the freeze escrow ATA account is closed.
    t.false(await umi.rpc.accountExists((0, mpl_toolbox_1.findAssociatedTokenPda)(umi, {
        mint: mint.publicKey,
        owner: (0, src_1.findFreezeEscrowPda)(umi, {
            destination,
            candyMachine,
            candyGuard: (0, src_1.findCandyGuardPda)(umi, { base: candyMachine })[0],
        })[0],
    })[0]));
});
const getFreezeEscrow = (umi, candyMachine, destination) => (0, src_1.findFreezeEscrowPda)(umi, {
    candyMachine,
    candyGuard: (0, src_1.findCandyGuardPda)(umi, { base: candyMachine })[0],
    destination: (0, umi_1.publicKey)(destination),
});
const getFrozenCount = async (umi, candyMachine, destination) => {
    const pda = getFreezeEscrow(umi, candyMachine, destination);
    const account = await (0, src_1.fetchFreezeEscrow)(umi, pda);
    return Number(account.frozenCount);
};
const assertFrozenCount = async (t, umi, candyMachine, destination, expected) => {
    const frozenCount = await getFrozenCount(umi, candyMachine, destination);
    t.is(frozenCount, expected, 'frozen count is correct');
};
const initFreezeEscrow = async (umi, candyMachine, destination, group) => {
    await (0, src_1.route)(umi, {
        candyMachine,
        guard: 'freezeSolPayment',
        group: group ? (0, umi_1.some)(group) : (0, umi_1.none)(),
        routeArgs: {
            path: 'initialize',
            period: 15 * 24 * 3600,
            candyGuardAuthority: umi.identity,
            destination,
        },
    }).sendAndConfirm(umi);
};
const mintNft = async (umi, candyMachine, destination, collectionMint, group) => {
    const mint = (0, umi_1.generateSigner)(umi);
    await (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 600000 }))
        .add((0, src_1.mintV2)(umi, {
        candyMachine,
        nftMint: mint,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
        mintArgs: {
            freezeSolPayment: (0, umi_1.some)({ destination }),
        },
        group: group ? (0, umi_1.some)(group) : (0, umi_1.none)(),
    }))
        .sendAndConfirm(umi);
    return mint;
};
const thawNft = async (umi, candyMachine, destination, nftMint, group, nftOwner) => {
    const candyMachineAccount = await (0, src_1.fetchCandyMachine)(umi, candyMachine);
    await (0, src_1.route)(umi, {
        candyMachine,
        guard: 'freezeSolPayment',
        group: group ? (0, umi_1.some)(group) : (0, umi_1.none)(),
        routeArgs: {
            path: 'thaw',
            nftMint,
            nftOwner: nftOwner ?? umi.identity.publicKey,
            nftTokenStandard: candyMachineAccount.tokenStandard,
            destination,
        },
    }).sendAndConfirm(umi);
};
const unlockFunds = async (umi, candyMachine, destination, group, candyGuardAuthority) => {
    await (0, src_1.route)(umi, {
        candyMachine,
        guard: 'freezeSolPayment',
        group: group ? (0, umi_1.some)(group) : (0, umi_1.none)(),
        routeArgs: {
            path: 'unlockFunds',
            candyGuardAuthority: candyGuardAuthority ?? umi.identity,
            destination,
        },
    }).sendAndConfirm(umi);
};
//# sourceMappingURL=freezeSolPayment.test.js.map