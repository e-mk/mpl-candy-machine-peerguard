"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const mpl_toolbox_1 = require("@metaplex-foundation/mpl-toolbox");
const umi_1 = require("@metaplex-foundation/umi");
const ava_1 = __importDefault(require("ava"));
const src_1 = require("../../src");
const _setup_1 = require("../_setup");
(0, ava_1.default)('it allows minting from wallets of a predefined list', async (t) => {
    // Given the identity is part of an allow list.
    const umi = await (0, _setup_1.createUmi)();
    const allowList = [
        (0, umi_1.base58PublicKey)(umi.identity),
        'Ur1CbWSGsXCdedknRbJsEk7urwAvu1uddmQv51nAnXB',
        'GjwcWFQYzemBtpUoN5fMAP2FZviTtMRWCmrppGuTthJS',
        '2vjCrmEFiN9CLLhiqy8u1JPh48av8Zpzp3kNkdTtirYG',
        'AT8nPwujHAD14cLojTcB1qdBzA1VXnT6LVGuUd6Y73Cy',
    ];
    const merkleRoot = (0, src_1.getMerkleRoot)(allowList);
    // And given a loaded Candy Machine with the allow list guard.
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        configLines: [{ name: 'Degen #1', uri: 'https://example.com/degen/1' }],
        guards: {
            allowList: (0, umi_1.some)({ merkleRoot }),
        },
    });
    // When we verify the payer first by providing a valid merkle proof.
    await (0, umi_1.transactionBuilder)()
        .add((0, src_1.route)(umi, {
        candyMachine,
        guard: 'allowList',
        routeArgs: {
            path: 'proof',
            merkleRoot,
            merkleProof: (0, src_1.getMerkleProof)(allowList, (0, umi_1.base58PublicKey)(umi.identity)),
        },
    }))
        .sendAndConfirm(umi);
    // And then mint from the Candy Machine using the identity.
    const mint = (0, umi_1.generateSigner)(umi);
    await (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 600000 }))
        .add((0, src_1.mintV2)(umi, {
        candyMachine,
        nftMint: mint,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
        mintArgs: { allowList: (0, umi_1.some)({ merkleRoot }) },
    }))
        .sendAndConfirm(umi);
    // Then minting was successful.
    await (0, _setup_1.assertSuccessfulMint)(t, umi, { mint, owner: umi.identity });
});
(0, ava_1.default)('it is possible to verify the proof and mint in the same transaction if there is space', async (t) => {
    // Given the identity is part of an allow list.
    const umi = await (0, _setup_1.createUmi)();
    const allowList = [
        (0, umi_1.base58PublicKey)(umi.identity),
        'Ur1CbWSGsXCdedknRbJsEk7urwAvu1uddmQv51nAnXB',
        'GjwcWFQYzemBtpUoN5fMAP2FZviTtMRWCmrppGuTthJS',
        '2vjCrmEFiN9CLLhiqy8u1JPh48av8Zpzp3kNkdTtirYG',
        'AT8nPwujHAD14cLojTcB1qdBzA1VXnT6LVGuUd6Y73Cy',
    ];
    const merkleRoot = (0, src_1.getMerkleRoot)(allowList);
    // And given a loaded Candy Machine with the allow list guard.
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        configLines: [{ name: 'Degen #1', uri: 'https://example.com/degen/1' }],
        guards: {
            allowList: (0, umi_1.some)({ merkleRoot }),
        },
    });
    // When we verify the identity using a valid merkle proof
    // and mint from the Candy Machine at the same time.
    const mint = (0, umi_1.generateSigner)(umi);
    await (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 600000 }))
        .add((0, src_1.route)(umi, {
        candyMachine,
        guard: 'allowList',
        routeArgs: {
            path: 'proof',
            merkleRoot,
            merkleProof: (0, src_1.getMerkleProof)(allowList, (0, umi_1.base58PublicKey)(umi.identity)),
        },
    }))
        .add((0, src_1.mintV2)(umi, {
        candyMachine,
        nftMint: mint,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
        mintArgs: { allowList: (0, umi_1.some)({ merkleRoot }) },
    }))
        .sendAndConfirm(umi);
    // Then minting was successful.
    await (0, _setup_1.assertSuccessfulMint)(t, umi, { mint, owner: umi.identity });
});
(0, ava_1.default)('it allows minting even when the payer is different from the minter', async (t) => {
    // Given a separate minter that is part of an allow list.
    const umi = await (0, _setup_1.createUmi)();
    const minter = (0, umi_1.generateSigner)(umi);
    const allowList = [
        (0, umi_1.base58PublicKey)(minter),
        'Ur1CbWSGsXCdedknRbJsEk7urwAvu1uddmQv51nAnXB',
        'GjwcWFQYzemBtpUoN5fMAP2FZviTtMRWCmrppGuTthJS',
        '2vjCrmEFiN9CLLhiqy8u1JPh48av8Zpzp3kNkdTtirYG',
        'AT8nPwujHAD14cLojTcB1qdBzA1VXnT6LVGuUd6Y73Cy',
    ];
    const merkleRoot = (0, src_1.getMerkleRoot)(allowList);
    // And given a loaded Candy Machine with the allow list guard.
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        configLines: [{ name: 'Degen #1', uri: 'https://example.com/degen/1' }],
        guards: {
            allowList: (0, umi_1.some)({ merkleRoot }),
        },
    });
    // When we verify and mint from the Candy Machine using the minter.
    const mint = (0, umi_1.generateSigner)(umi);
    await (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 600000 }))
        .add((0, src_1.route)(umi, {
        candyMachine,
        guard: 'allowList',
        routeArgs: {
            path: 'proof',
            merkleRoot,
            merkleProof: (0, src_1.getMerkleProof)(allowList, (0, umi_1.base58PublicKey)(minter)),
            minter: (0, umi_1.publicKey)(minter), // <-- We need to tell the route instruction who the minter is.
        },
    }))
        .add((0, src_1.mintV2)(umi, {
        candyMachine,
        nftMint: mint,
        minter,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
        mintArgs: { allowList: (0, umi_1.some)({ merkleRoot }) },
    }))
        .sendAndConfirm(umi);
    // Then minting was successful.
    await (0, _setup_1.assertSuccessfulMint)(t, umi, { mint, owner: minter });
});
(0, ava_1.default)('it forbids minting from wallets that are not part of a predefined list', async (t) => {
    // Given the identity is not part of the allow list.
    const umi = await (0, _setup_1.createUmi)();
    const allowList = [
        'Ur1CbWSGsXCdedknRbJsEk7urwAvu1uddmQv51nAnXB',
        'GjwcWFQYzemBtpUoN5fMAP2FZviTtMRWCmrppGuTthJS',
        '2vjCrmEFiN9CLLhiqy8u1JPh48av8Zpzp3kNkdTtirYG',
        'AT8nPwujHAD14cLojTcB1qdBzA1VXnT6LVGuUd6Y73Cy',
    ];
    const merkleRoot = (0, src_1.getMerkleRoot)(allowList);
    // And given a loaded Candy Machine with the allow list guard.
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        configLines: [{ name: 'Degen #1', uri: 'https://example.com/degen/1' }],
        guards: {
            allowList: (0, umi_1.some)({ merkleRoot }),
        },
    });
    // When the identity tries to verify itself on the allow list.
    const promise = (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 600000 }))
        .add((0, src_1.route)(umi, {
        candyMachine,
        guard: 'allowList',
        routeArgs: {
            path: 'proof',
            merkleRoot,
            merkleProof: (0, src_1.getMerkleProof)(allowList, (0, umi_1.base58PublicKey)(umi.identity)),
        },
    }))
        .sendAndConfirm(umi);
    // Then we expect a program error.
    await t.throwsAsync(promise, { message: /AddressNotFoundInAllowedList/ });
});
(0, ava_1.default)('it forbids minting from wallets that are providing the wrong proof', async (t) => {
    // Given the identity is part of the allow list.
    const umi = await (0, _setup_1.createUmi)();
    const allowList = [
        (0, umi_1.base58PublicKey)(umi.identity),
        'Ur1CbWSGsXCdedknRbJsEk7urwAvu1uddmQv51nAnXB',
        'GjwcWFQYzemBtpUoN5fMAP2FZviTtMRWCmrppGuTthJS',
        '2vjCrmEFiN9CLLhiqy8u1JPh48av8Zpzp3kNkdTtirYG',
        'AT8nPwujHAD14cLojTcB1qdBzA1VXnT6LVGuUd6Y73Cy',
    ];
    const merkleRoot = (0, src_1.getMerkleRoot)(allowList);
    // And given a loaded Candy Machine with the allow list guard.
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        configLines: [{ name: 'Degen #1', uri: 'https://example.com/degen/1' }],
        guards: {
            allowList: (0, umi_1.some)({ merkleRoot }),
        },
    });
    // When the identity tries to verify itself using the wrong proof.
    const wrongProof = (0, src_1.getMerkleProof)(allowList, 'Ur1CbWSGsXCdedknRbJsEk7urwAvu1uddmQv51nAnXB');
    const promise = (0, umi_1.transactionBuilder)()
        .add((0, src_1.route)(umi, {
        candyMachine,
        guard: 'allowList',
        routeArgs: {
            path: 'proof',
            merkleRoot,
            merkleProof: wrongProof,
        },
    }))
        .sendAndConfirm(umi);
    // Then we expect a program error.
    await t.throwsAsync(promise, { message: /AddressNotFoundInAllowedList/ });
});
(0, ava_1.default)('it forbids minting if the wallet has not been verified via the route instruction first', async (t) => {
    // Given the identity is part of an allow list.
    const umi = await (0, _setup_1.createUmi)();
    const allowList = [
        (0, umi_1.base58PublicKey)(umi.identity),
        'Ur1CbWSGsXCdedknRbJsEk7urwAvu1uddmQv51nAnXB',
        'GjwcWFQYzemBtpUoN5fMAP2FZviTtMRWCmrppGuTthJS',
        '2vjCrmEFiN9CLLhiqy8u1JPh48av8Zpzp3kNkdTtirYG',
        'AT8nPwujHAD14cLojTcB1qdBzA1VXnT6LVGuUd6Y73Cy',
    ];
    const merkleRoot = (0, src_1.getMerkleRoot)(allowList);
    // And given a loaded Candy Machine with an allow list guard.
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        configLines: [{ name: 'Degen #1', uri: 'https://example.com/degen/1' }],
        guards: {
            allowList: (0, umi_1.some)({ merkleRoot }),
        },
    });
    // When the identity tries to mints from that Candy Machine
    // without having been verified via the route instruction.
    const mint = (0, umi_1.generateSigner)(umi);
    const promise = (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 600000 }))
        .add((0, src_1.mintV2)(umi, {
        candyMachine,
        nftMint: mint,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
        mintArgs: { allowList: (0, umi_1.some)({ merkleRoot }) },
    }))
        .sendAndConfirm(umi);
    // Then we expect a program error.
    await t.throwsAsync(promise, { message: /MissingAllowedListProof/ });
});
(0, ava_1.default)('it charges a bot tax when trying to mint whilst not verified', async (t) => {
    // Given the identity is part of an allow list.
    const umi = await (0, _setup_1.createUmi)();
    const allowList = [
        (0, umi_1.base58PublicKey)(umi.identity),
        'Ur1CbWSGsXCdedknRbJsEk7urwAvu1uddmQv51nAnXB',
        'GjwcWFQYzemBtpUoN5fMAP2FZviTtMRWCmrppGuTthJS',
        '2vjCrmEFiN9CLLhiqy8u1JPh48av8Zpzp3kNkdTtirYG',
        'AT8nPwujHAD14cLojTcB1qdBzA1VXnT6LVGuUd6Y73Cy',
    ];
    const merkleRoot = (0, src_1.getMerkleRoot)(allowList);
    // And given a loaded Candy Machine with an allow list and a bot tax guard.
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        configLines: [{ name: 'Degen #1', uri: 'https://example.com/degen/1' }],
        guards: {
            botTax: (0, umi_1.some)({ lamports: (0, umi_1.sol)(0.01), lastInstruction: true }),
            allowList: (0, umi_1.some)({ merkleRoot }),
        },
    });
    // When the identity tries to mints from that Candy Machine
    // without having been verified via the route instruction.
    const mint = (0, umi_1.generateSigner)(umi);
    const { signature } = await (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 600000 }))
        .add((0, src_1.mintV2)(umi, {
        candyMachine,
        nftMint: mint,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
        mintArgs: { allowList: (0, umi_1.some)({ merkleRoot }) },
    }))
        .sendAndConfirm(umi);
    // Then we expect a silent bot tax error.
    await (0, _setup_1.assertBotTax)(t, umi, mint, signature, /MissingAllowedListProof/);
});
(0, ava_1.default)('it creates a proof for a minter even when the minter is not a signer', async (t) => {
    // Given a separate minter that is part of an allow list and not a signer.
    const umi = await (0, _setup_1.createUmi)();
    const minter = (0, umi_1.generateSigner)(umi).publicKey;
    const allowList = [
        (0, umi_1.base58PublicKey)(minter),
        'Ur1CbWSGsXCdedknRbJsEk7urwAvu1uddmQv51nAnXB',
        'GjwcWFQYzemBtpUoN5fMAP2FZviTtMRWCmrppGuTthJS',
        '2vjCrmEFiN9CLLhiqy8u1JPh48av8Zpzp3kNkdTtirYG',
        'AT8nPwujHAD14cLojTcB1qdBzA1VXnT6LVGuUd6Y73Cy',
    ];
    const merkleRoot = (0, src_1.getMerkleRoot)(allowList);
    // And given a loaded Candy Machine with the allow list guard.
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        configLines: [{ name: 'Degen #1', uri: 'https://example.com/degen/1' }],
        guards: {
            allowList: (0, umi_1.some)({ merkleRoot }),
        },
    });
    // When we verify the minter on the allow list from the Candy Machine.
    await (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 600000 }))
        .add((0, src_1.route)(umi, {
        candyMachine,
        guard: 'allowList',
        routeArgs: {
            path: 'proof',
            merkleRoot,
            merkleProof: (0, src_1.getMerkleProof)(allowList, (0, umi_1.base58PublicKey)(minter)),
            minter, // <-- We need to tell the route instruction who the minter is.
        },
    }))
        .sendAndConfirm(umi);
    // Then a proof has been created for the minter.
    const [candyGuard] = (0, src_1.findCandyGuardPda)(umi, { base: candyMachine });
    t.true(await umi.rpc.accountExists((0, src_1.findAllowListProofPda)(umi, {
        candyGuard,
        candyMachine,
        merkleRoot,
        user: minter,
    })[0]));
    // But no proof has been created for the payer.
    t.false(await umi.rpc.accountExists((0, src_1.findAllowListProofPda)(umi, {
        candyGuard,
        candyMachine,
        merkleRoot,
        user: (0, umi_1.publicKey)(umi.payer),
    })[0]));
});
(0, ava_1.default)('it creates a proof for the payer when the minter is not present', async (t) => {
    // Given the payer that is part of an allow list.
    const umi = await (0, _setup_1.createUmi)();
    const allowList = [
        (0, umi_1.base58PublicKey)(umi.payer),
        'Ur1CbWSGsXCdedknRbJsEk7urwAvu1uddmQv51nAnXB',
        'GjwcWFQYzemBtpUoN5fMAP2FZviTtMRWCmrppGuTthJS',
        '2vjCrmEFiN9CLLhiqy8u1JPh48av8Zpzp3kNkdTtirYG',
        'AT8nPwujHAD14cLojTcB1qdBzA1VXnT6LVGuUd6Y73Cy',
    ];
    const merkleRoot = (0, src_1.getMerkleRoot)(allowList);
    // And given a loaded Candy Machine with the allow list guard.
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        configLines: [{ name: 'Degen #1', uri: 'https://example.com/degen/1' }],
        guards: {
            allowList: (0, umi_1.some)({ merkleRoot }),
        },
    });
    // When we verify the payer on the allow list from the Candy Machine.
    await (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 600000 }))
        .add((0, src_1.route)(umi, {
        candyMachine,
        guard: 'allowList',
        routeArgs: {
            path: 'proof',
            merkleRoot,
            merkleProof: (0, src_1.getMerkleProof)(allowList, (0, umi_1.base58PublicKey)(umi.payer)),
        },
    }))
        .sendAndConfirm(umi);
    // Then a proof has been created for the payer.
    const [candyGuard] = (0, src_1.findCandyGuardPda)(umi, { base: candyMachine });
    t.true(await umi.rpc.accountExists((0, src_1.findAllowListProofPda)(umi, {
        candyGuard,
        candyMachine,
        merkleRoot,
        user: (0, umi_1.publicKey)(umi.payer),
    })[0]));
});
//# sourceMappingURL=allowList.test.js.map