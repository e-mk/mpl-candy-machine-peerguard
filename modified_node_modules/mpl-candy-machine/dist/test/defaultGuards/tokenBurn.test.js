"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const umi_1 = require("@metaplex-foundation/umi");
const ava_1 = __importDefault(require("ava"));
const mpl_toolbox_1 = require("@metaplex-foundation/mpl-toolbox");
const _setup_1 = require("../_setup");
const src_1 = require("../../src");
(0, ava_1.default)('it burns a specific token to allow minting', async (t) => {
    // Given a payer with one token.
    const umi = await (0, _setup_1.createUmi)();
    const tokenMint = (0, umi_1.generateSigner)(umi);
    await (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.createMintWithAssociatedToken)(umi, {
        mint: tokenMint,
        owner: umi.identity.publicKey,
        amount: 1,
    }))
        .sendAndConfirm(umi);
    // And a loaded Candy Machine with the tokenBurn guard.
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        configLines: [{ name: 'Degen #1', uri: 'https://example.com/degen/1' }],
        guards: {
            tokenBurn: (0, umi_1.some)({ mint: tokenMint.publicKey, amount: 1 }),
        },
    });
    // When the payer mints from it.
    const mint = (0, umi_1.generateSigner)(umi);
    await (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 600000 }))
        .add((0, src_1.mintV2)(umi, {
        candyMachine,
        nftMint: mint,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
        mintArgs: {
            tokenBurn: (0, umi_1.some)({ mint: tokenMint.publicKey }),
        },
    }))
        .sendAndConfirm(umi);
    // Then minting was successful.
    await (0, _setup_1.assertSuccessfulMint)(t, umi, { mint, owner: umi.identity });
    // And the payer's token was burned.
    const tokenAccount = await (0, mpl_toolbox_1.fetchToken)(umi, (0, mpl_toolbox_1.findAssociatedTokenPda)(umi, {
        mint: tokenMint.publicKey,
        owner: umi.identity.publicKey,
    }));
    t.is(tokenAccount.amount, 0n);
});
(0, ava_1.default)('it allows minting even when the payer is different from the minter', async (t) => {
    // Given an explicit minter with one token.
    const umi = await (0, _setup_1.createUmi)();
    const minter = (0, umi_1.generateSigner)(umi);
    const tokenMint = (0, umi_1.generateSigner)(umi);
    await (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.createMintWithAssociatedToken)(umi, {
        mint: tokenMint,
        owner: minter.publicKey,
        amount: 1,
    }))
        .sendAndConfirm(umi);
    // And a loaded Candy Machine with the tokenBurn guard.
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        configLines: [{ name: 'Degen #1', uri: 'https://example.com/degen/1' }],
        guards: {
            tokenBurn: (0, umi_1.some)({ mint: tokenMint.publicKey, amount: 1 }),
        },
    });
    // When the minter mints from it.
    const mint = (0, umi_1.generateSigner)(umi);
    await (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 600000 }))
        .add((0, src_1.mintV2)(umi, {
        candyMachine,
        nftMint: mint,
        minter,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
        mintArgs: {
            tokenBurn: (0, umi_1.some)({ mint: tokenMint.publicKey }),
        },
    }))
        .sendAndConfirm(umi);
    // Then minting was successful.
    await (0, _setup_1.assertSuccessfulMint)(t, umi, { mint, owner: minter });
    // And the minter's token was burned.
    const tokenAccount = await (0, mpl_toolbox_1.fetchToken)(umi, (0, mpl_toolbox_1.findAssociatedTokenPda)(umi, {
        mint: tokenMint.publicKey,
        owner: minter.publicKey,
    }));
    t.is(tokenAccount.amount, 0n);
});
(0, ava_1.default)('it may burn multiple tokens from a specific mint', async (t) => {
    // Given a payer with 42 tokens.
    const umi = await (0, _setup_1.createUmi)();
    const tokenMint = (0, umi_1.generateSigner)(umi);
    await (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.createMintWithAssociatedToken)(umi, {
        mint: tokenMint,
        owner: umi.identity.publicKey,
        amount: 42,
    }))
        .sendAndConfirm(umi);
    // And a loaded Candy Machine with the tokenBurn guard that requires 5 tokens.
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        configLines: [{ name: 'Degen #1', uri: 'https://example.com/degen/1' }],
        guards: {
            tokenBurn: (0, umi_1.some)({ mint: tokenMint.publicKey, amount: 5 }),
        },
    });
    // When the payer mints from it.
    const mint = (0, umi_1.generateSigner)(umi);
    await (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 600000 }))
        .add((0, src_1.mintV2)(umi, {
        candyMachine,
        nftMint: mint,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
        mintArgs: {
            tokenBurn: (0, umi_1.some)({ mint: tokenMint.publicKey }),
        },
    }))
        .sendAndConfirm(umi);
    // Then minting was successful.
    await (0, _setup_1.assertSuccessfulMint)(t, umi, { mint, owner: umi.identity });
    // And the payer lost 5 tokens.
    const tokenAccount = await (0, mpl_toolbox_1.fetchToken)(umi, (0, mpl_toolbox_1.findAssociatedTokenPda)(umi, {
        mint: tokenMint.publicKey,
        owner: umi.identity.publicKey,
    }));
    t.is(tokenAccount.amount, 37n);
});
(0, ava_1.default)('it fails to mint if there are not enough tokens to burn', async (t) => {
    // Given a payer with one token.
    const umi = await (0, _setup_1.createUmi)();
    const tokenMint = (0, umi_1.generateSigner)(umi);
    await (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.createMintWithAssociatedToken)(umi, {
        mint: tokenMint,
        owner: umi.identity.publicKey,
        amount: 1,
    }))
        .sendAndConfirm(umi);
    // And a loaded Candy Machine with the tokenBurn guard that requires 2 tokens.
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        configLines: [{ name: 'Degen #1', uri: 'https://example.com/degen/1' }],
        guards: {
            tokenBurn: (0, umi_1.some)({ mint: tokenMint.publicKey, amount: 2 }),
        },
    });
    // When the payer tries to mint from it.
    const mint = (0, umi_1.generateSigner)(umi);
    const promise = (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 600000 }))
        .add((0, src_1.mintV2)(umi, {
        candyMachine,
        nftMint: mint,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
        mintArgs: {
            tokenBurn: (0, umi_1.some)({ mint: tokenMint.publicKey }),
        },
    }))
        .sendAndConfirm(umi);
    // Then we expect a program error.
    await t.throwsAsync(promise, { message: /NotEnoughTokens/ });
    // And the payer still has one token.
    const tokenAccount = await (0, mpl_toolbox_1.fetchToken)(umi, (0, mpl_toolbox_1.findAssociatedTokenPda)(umi, {
        mint: tokenMint.publicKey,
        owner: umi.identity.publicKey,
    }));
    t.is(tokenAccount.amount, 1n);
});
(0, ava_1.default)('it charges a bot tax when trying to mint without the required amount of tokens', async (t) => {
    // Given a payer with one token.
    const umi = await (0, _setup_1.createUmi)();
    const tokenMint = (0, umi_1.generateSigner)(umi);
    await (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.createMintWithAssociatedToken)(umi, {
        mint: tokenMint,
        owner: umi.identity.publicKey,
        amount: 1,
    }))
        .sendAndConfirm(umi);
    // And a loaded Candy Machine with a botTax guard and a tokenBurn guard that requires 2 tokens.
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        configLines: [{ name: 'Degen #1', uri: 'https://example.com/degen/1' }],
        guards: {
            botTax: (0, umi_1.some)({ lamports: (0, umi_1.sol)(0.1), lastInstruction: true }),
            tokenBurn: (0, umi_1.some)({ mint: tokenMint.publicKey, amount: 2 }),
        },
    });
    // When the payer tries to mint from it.
    const mint = (0, umi_1.generateSigner)(umi);
    const { signature } = await (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 600000 }))
        .add((0, src_1.mintV2)(umi, {
        candyMachine,
        nftMint: mint,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
        mintArgs: {
            tokenBurn: (0, umi_1.some)({ mint: tokenMint.publicKey }),
        },
    }))
        .sendAndConfirm(umi);
    // Then we expect a silent bot tax error.
    await (0, _setup_1.assertBotTax)(t, umi, mint, signature, /NotEnoughTokens/);
    // And the payer still has one token.
    const tokenAccount = await (0, mpl_toolbox_1.fetchToken)(umi, (0, mpl_toolbox_1.findAssociatedTokenPda)(umi, {
        mint: tokenMint.publicKey,
        owner: umi.identity.publicKey,
    }));
    t.is(tokenAccount.amount, 1n);
});
//# sourceMappingURL=tokenBurn.test.js.map