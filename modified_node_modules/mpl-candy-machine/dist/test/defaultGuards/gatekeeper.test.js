"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const solana_gateway_ts_1 = require("@identity.com/solana-gateway-ts");
const mpl_toolbox_1 = require("@metaplex-foundation/mpl-toolbox");
const umi_1 = require("@metaplex-foundation/umi");
const umi_bundle_tests_1 = require("@metaplex-foundation/umi-bundle-tests");
const umi_web3js_adapters_1 = require("@metaplex-foundation/umi-web3js-adapters");
const ava_1 = __importDefault(require("ava"));
const buffer_1 = require("buffer");
const src_1 = require("../../src");
const _setup_1 = require("../_setup");
(0, ava_1.default)('it allows minting via a gatekeeper service', async (t) => {
    // Given a Gatekeeper Network.
    const umi = await (0, _setup_1.createUmi)();
    const { gatekeeperNetwork, gatekeeperAuthority } = await createGatekeeperNetwork(umi);
    // And given the identity has a valid gateway Token Account from that network.
    const gatewayTokenAccount = await issueGatewayToken(umi, gatekeeperNetwork.publicKey, gatekeeperAuthority, umi.identity);
    // And a loaded Candy Machine with a gatekeeper guard on that network.
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        configLines: [{ name: 'Degen #1', uri: 'https://example.com/degen/1' }],
        guards: {
            gatekeeper: (0, umi_1.some)({
                gatekeeperNetwork: gatekeeperNetwork.publicKey,
                expireOnUse: false,
            }),
        },
    });
    // When the identity mints from the Candy Machine using its valid token.
    const mint = (0, umi_1.generateSigner)(umi);
    await (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 600000 }))
        .add((0, src_1.mintV2)(umi, {
        candyMachine,
        nftMint: mint,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
        mintArgs: {
            gatekeeper: (0, umi_1.some)({
                gatekeeperNetwork: gatekeeperNetwork.publicKey,
                expireOnUse: false,
                tokenAccount: gatewayTokenAccount,
            }),
        },
    }))
        .sendAndConfirm(umi);
    // Then minting was successful.
    await (0, _setup_1.assertSuccessfulMint)(t, umi, { mint, owner: umi.identity });
});
(0, ava_1.default)('it defaults to calculating the gateway token PDA for us', async (t) => {
    // Given a Gatekeeper Network.
    const umi = await (0, _setup_1.createUmi)();
    const { gatekeeperNetwork, gatekeeperAuthority } = await createGatekeeperNetwork(umi);
    // And given the identity has a valid gateway Token Account from that network.
    await issueGatewayToken(umi, gatekeeperNetwork.publicKey, gatekeeperAuthority, umi.identity);
    // And a loaded Candy Machine with a gatekeeper guard on that network.
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        configLines: [{ name: 'Degen #1', uri: 'https://example.com/degen/1' }],
        guards: {
            gatekeeper: (0, umi_1.some)({
                gatekeeperNetwork: gatekeeperNetwork.publicKey,
                expireOnUse: false,
            }),
        },
    });
    // When that payer mints from the Candy Machine without passing in its valid token.
    const mint = (0, umi_1.generateSigner)(umi);
    await (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 600000 }))
        .add((0, src_1.mintV2)(umi, {
        candyMachine,
        nftMint: mint,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
        mintArgs: {
            gatekeeper: (0, umi_1.some)({
                gatekeeperNetwork: gatekeeperNetwork.publicKey,
                expireOnUse: false,
            }),
        },
    }))
        .sendAndConfirm(umi);
    // Then minting was still successful.
    await (0, _setup_1.assertSuccessfulMint)(t, umi, { mint, owner: umi.identity });
});
(0, ava_1.default)('it allows minting even when the payer is different from the minter', async (t) => {
    // Given a Gatekeeper Network.
    const umi = await (0, _setup_1.createUmi)();
    const { gatekeeperNetwork, gatekeeperAuthority } = await createGatekeeperNetwork(umi);
    // And a separate minter that has a valid gateway Token Account from that network.
    const minter = (0, umi_1.generateSigner)(umi);
    await issueGatewayToken(umi, gatekeeperNetwork.publicKey, gatekeeperAuthority, umi.payer, minter.publicKey);
    // And a loaded Candy Machine with a gatekeeper guard on that network.
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        configLines: [{ name: 'Degen #1', uri: 'https://example.com/degen/1' }],
        guards: {
            gatekeeper: (0, umi_1.some)({
                gatekeeperNetwork: gatekeeperNetwork.publicKey,
                expireOnUse: false,
            }),
        },
    });
    // When that minter mints from the Candy Machine without passing in its valid token.
    const mint = (0, umi_1.generateSigner)(umi);
    await (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 600000 }))
        .add((0, src_1.mintV2)(umi, {
        candyMachine,
        nftMint: mint,
        minter,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
        mintArgs: {
            gatekeeper: (0, umi_1.some)({
                gatekeeperNetwork: gatekeeperNetwork.publicKey,
                expireOnUse: false,
            }),
        },
    }))
        .sendAndConfirm(umi);
    // Then minting was still successful.
    await (0, _setup_1.assertSuccessfulMint)(t, umi, { mint, owner: minter });
});
(0, ava_1.default)('it forbids minting when providing the wrong token', async (t) => {
    // Given a Gatekeeper Network such that the identity
    // has no valid gateway Token Account from that network.
    const umi = await (0, _setup_1.createUmi)();
    const { gatekeeperNetwork } = await createGatekeeperNetwork(umi);
    // Given a loaded Candy Machine with a gatekeeper guard.
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        configLines: [{ name: 'Degen #1', uri: 'https://example.com/degen/1' }],
        guards: {
            gatekeeper: (0, umi_1.some)({
                gatekeeperNetwork: gatekeeperNetwork.publicKey,
                expireOnUse: false,
            }),
        },
    });
    // When the payer tries to mint from it with the wrong token.
    const mint = (0, umi_1.generateSigner)(umi);
    const promise = (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 600000 }))
        .add((0, src_1.mintV2)(umi, {
        candyMachine,
        nftMint: mint,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
        mintArgs: {
            gatekeeper: (0, umi_1.some)({
                gatekeeperNetwork: gatekeeperNetwork.publicKey,
                expireOnUse: false,
            }),
        },
    }))
        .sendAndConfirm(umi);
    // Then we expect an error.
    await t.throwsAsync(promise, { message: /GatewayTokenInvalid/ });
});
(0, ava_1.default)('it allows minting using gateway tokens that expire when they are still valid', async (t) => {
    // Given a Gatekeeper Network.
    const umi = await (0, _setup_1.createUmi)();
    const { gatekeeperNetwork, gatekeeperAuthority } = await createGatekeeperNetwork(umi);
    // And given the identity has a valid gateway Token Account
    // from that network that has not yet expired.
    const gatewayTokenAccount = await issueGatewayToken(umi, gatekeeperNetwork.publicKey, gatekeeperAuthority, umi.identity, umi.identity.publicKey, (0, _setup_1.tomorrow)());
    // And a loaded Candy Machine with a gatekeeper guard on that network.
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        configLines: [{ name: 'Degen #1', uri: 'https://example.com/degen/1' }],
        guards: {
            gatekeeper: (0, umi_1.some)({
                gatekeeperNetwork: gatekeeperNetwork.publicKey,
                expireOnUse: false,
            }),
        },
    });
    // When that identity mints from the Candy Machine using its non-expired token.
    const mint = (0, umi_1.generateSigner)(umi);
    await (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 600000 }))
        .add((0, src_1.mintV2)(umi, {
        candyMachine,
        nftMint: mint,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
        mintArgs: {
            gatekeeper: (0, umi_1.some)({
                gatekeeperNetwork: gatekeeperNetwork.publicKey,
                expireOnUse: false,
                tokenAccount: gatewayTokenAccount,
            }),
        },
    }))
        .sendAndConfirm(umi);
    // Then minting was successful.
    await (0, _setup_1.assertSuccessfulMint)(t, umi, { mint, owner: umi.identity });
});
(0, ava_1.default)('it forbids minting using gateway tokens that have expired', async (t) => {
    // Given a Gatekeeper Network.
    const umi = await (0, _setup_1.createUmi)();
    const { gatekeeperNetwork, gatekeeperAuthority } = await createGatekeeperNetwork(umi);
    // And given the identity has a gateway Token Account from that network that has expired.
    const expiredGatewayTokenAccount = await issueGatewayToken(umi, gatekeeperNetwork.publicKey, gatekeeperAuthority, umi.identity, umi.identity.publicKey, (0, _setup_1.yesterday)());
    // And a loaded Candy Machine with a gatekeeper guard on that network.
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        configLines: [{ name: 'Degen #1', uri: 'https://example.com/degen/1' }],
        guards: {
            gatekeeper: (0, umi_1.some)({
                gatekeeperNetwork: gatekeeperNetwork.publicKey,
                expireOnUse: false,
            }),
        },
    });
    // When the payer tries to mint from the Candy Machine using its expired token.
    const mint = (0, umi_1.generateSigner)(umi);
    const promise = (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 600000 }))
        .add((0, src_1.mintV2)(umi, {
        candyMachine,
        nftMint: mint,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
        mintArgs: {
            gatekeeper: (0, umi_1.some)({
                gatekeeperNetwork: gatekeeperNetwork.publicKey,
                expireOnUse: false,
                tokenAccount: expiredGatewayTokenAccount,
            }),
        },
    }))
        .sendAndConfirm(umi);
    // Then we expect an error.
    await t.throwsAsync(promise, { message: /GatewayTokenInvalid/ });
});
(0, ava_1.default)('it may immediately mark gateway tokens as expired after using them', async (t) => {
    // Given a Gatekeeper Network.
    const umi = await (0, _setup_1.createUmi)();
    const { gatekeeperNetwork, gatekeeperAuthority } = await createGatekeeperNetwork(umi);
    // And given the identity has a valid gateway Token Account
    // from that network that is set to expire tomorrow.
    const tomorrowDateTime = (0, _setup_1.tomorrow)();
    const gatewayTokenAccount = await issueGatewayToken(umi, gatekeeperNetwork.publicKey, gatekeeperAuthority, umi.identity, umi.identity.publicKey, tomorrowDateTime);
    const gatewayTokenData = await getGatewayTokenData(umi, gatewayTokenAccount);
    t.true(!!gatewayTokenData.expiry, 'Gateway token expires');
    t.is(gatewayTokenData.expiry?.toNumber(), Number(tomorrowDateTime));
    // And a loaded Candy Machine with a gatekeeper guard
    // that mark tokens as expire after using them.
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        configLines: [{ name: 'Degen #1', uri: 'https://example.com/degen/1' }],
        guards: {
            gatekeeper: (0, umi_1.some)({
                gatekeeperNetwork: gatekeeperNetwork.publicKey,
                expireOnUse: true,
            }),
        },
    });
    // When the identity mints from the Candy Machine using its token.
    const mint = (0, umi_1.generateSigner)(umi);
    await (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 600000 }))
        .add((0, src_1.mintV2)(umi, {
        candyMachine,
        nftMint: mint,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
        mintArgs: {
            gatekeeper: (0, umi_1.some)({
                gatekeeperNetwork: gatekeeperNetwork.publicKey,
                expireOnUse: true,
                tokenAccount: gatewayTokenAccount,
            }),
        },
    }))
        .sendAndConfirm(umi);
    // Then minting was successful.
    await (0, _setup_1.assertSuccessfulMint)(t, umi, { mint, owner: umi.identity });
    // And the gateway token is now expired.
    const updatedGatewayTokenData = await getGatewayTokenData(umi, gatewayTokenAccount);
    t.true(!!updatedGatewayTokenData.expiry, 'Gateway token expires');
    const updateExpiry = updatedGatewayTokenData.expiry?.toNumber();
    t.true(updateExpiry < tomorrowDateTime, 'Gateway token expiry date was shortened');
});
(0, ava_1.default)('it charges a bot tax when trying to mint using the wrong token', async (t) => {
    // Given a Gatekeeper Network such that the identity doesn't
    // have a valid gateway Token Account from that network.
    const umi = await (0, _setup_1.createUmi)();
    const { gatekeeperNetwork } = await createGatekeeperNetwork(umi);
    // Given a loaded Candy Machine with a gatekeeper guard and a botTax guard.
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        configLines: [{ name: 'Degen #1', uri: 'https://example.com/degen/1' }],
        guards: {
            botTax: (0, umi_1.some)({ lamports: (0, umi_1.sol)(0.1), lastInstruction: true }),
            gatekeeper: (0, umi_1.some)({
                gatekeeperNetwork: gatekeeperNetwork.publicKey,
                expireOnUse: false,
            }),
        },
    });
    // When the identity tries to mint from it with no valid token.
    const mint = (0, umi_1.generateSigner)(umi);
    const { signature } = await (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 600000 }))
        .add((0, src_1.mintV2)(umi, {
        candyMachine,
        nftMint: mint,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
        mintArgs: {
            gatekeeper: (0, umi_1.some)({
                gatekeeperNetwork: gatekeeperNetwork.publicKey,
                expireOnUse: false,
            }),
        },
    }))
        .sendAndConfirm(umi);
    // Then we expect a bot tax error.
    await (0, _setup_1.assertBotTax)(t, umi, mint, signature, /GatewayTokenInvalid/);
});
const createGatekeeperNetwork = async (umi) => {
    // Prepare the accounts.
    const gatekeeperAuthority = await (0, umi_bundle_tests_1.generateSignerWithSol)(umi, (0, umi_1.sol)(10));
    const gatekeeperNetwork = (0, umi_1.generateSigner)(umi);
    const s = umi.serializer;
    const gatewayProgram = umi.programs.getPublicKey('civicGateway');
    const [gatekeeperAccount] = umi.eddsa.findPda(gatewayProgram, [
        s.publicKey().serialize(gatekeeperAuthority),
        s.publicKey().serialize(gatekeeperNetwork),
        s.string({ size: 'variable' }).serialize('gatekeeper'),
    ]);
    // Create the gatekeeper network.
    await (0, umi_1.transactionBuilder)()
        .add({
        instruction: (0, umi_web3js_adapters_1.fromWeb3JsInstruction)((0, solana_gateway_ts_1.addGatekeeper)((0, umi_web3js_adapters_1.toWeb3JsPublicKey)(gatekeeperAuthority.publicKey), (0, umi_web3js_adapters_1.toWeb3JsPublicKey)(gatekeeperAccount), (0, umi_web3js_adapters_1.toWeb3JsPublicKey)(gatekeeperAuthority.publicKey), (0, umi_web3js_adapters_1.toWeb3JsPublicKey)(gatekeeperNetwork.publicKey))),
        signers: [gatekeeperAuthority, gatekeeperNetwork],
        bytesCreatedOnChain: 0,
    })
        .sendAndConfirm(umi);
    // Add the expire feature to the gatekeeper network.
    await (0, umi_1.transactionBuilder)()
        .add({
        instruction: (0, umi_web3js_adapters_1.fromWeb3JsInstruction)(await (0, solana_gateway_ts_1.addFeatureToNetwork)((0, umi_web3js_adapters_1.toWeb3JsPublicKey)(gatekeeperAuthority.publicKey), (0, umi_web3js_adapters_1.toWeb3JsPublicKey)(gatekeeperNetwork.publicKey), new solana_gateway_ts_1.NetworkFeature({ userTokenExpiry: new solana_gateway_ts_1.UserTokenExpiry({}) }))),
        signers: [gatekeeperAuthority, gatekeeperNetwork],
        bytesCreatedOnChain: 0,
    })
        .sendAndConfirm(umi);
    return { gatekeeperNetwork, gatekeeperAuthority };
};
const issueGatewayToken = async (umi, gatekeeperNetwork, gatekeeperAuthority, payer, owner, expiryDate, seeds = [0, 0, 0, 0, 0, 0, 0, 0]) => {
    owner = owner ?? payer.publicKey;
    const s = umi.serializer;
    const gatewayProgram = umi.programs.getPublicKey('civicGateway');
    const [gatekeeperAccount] = umi.eddsa.findPda(gatewayProgram, [
        s.publicKey().serialize(gatekeeperAuthority),
        s.publicKey().serialize(gatekeeperNetwork),
        s.string({ size: 'variable' }).serialize('gatekeeper'),
    ]);
    const [gatewayTokenAccount] = umi.eddsa.findPda(gatewayProgram, [
        s.publicKey().serialize(owner),
        s.string({ size: 'variable' }).serialize('gateway'),
        s.array(s.u8(), { size: 8 }).serialize(seeds),
        s.publicKey().serialize(gatekeeperNetwork),
    ]);
    await (0, umi_1.transactionBuilder)()
        .add({
        instruction: (0, umi_web3js_adapters_1.fromWeb3JsInstruction)((0, solana_gateway_ts_1.issue)((0, umi_web3js_adapters_1.toWeb3JsPublicKey)(gatewayTokenAccount), (0, umi_web3js_adapters_1.toWeb3JsPublicKey)(payer.publicKey), (0, umi_web3js_adapters_1.toWeb3JsPublicKey)(gatekeeperAccount), (0, umi_web3js_adapters_1.toWeb3JsPublicKey)(owner), (0, umi_web3js_adapters_1.toWeb3JsPublicKey)(gatekeeperAuthority.publicKey), (0, umi_web3js_adapters_1.toWeb3JsPublicKey)(gatekeeperNetwork), new Uint8Array(seeds), expiryDate ? Number((0, umi_1.dateTime)(expiryDate)) : undefined)),
        signers: [payer, gatekeeperAuthority],
        bytesCreatedOnChain: 0,
    })
        .sendAndConfirm(umi);
    return gatewayTokenAccount;
};
const getGatewayTokenData = async (umi, gatewayTokenAccount) => {
    const account = await umi.rpc.getAccount(gatewayTokenAccount);
    (0, umi_1.assertAccountExists)(account);
    return solana_gateway_ts_1.GatewayTokenData.fromAccount(buffer_1.Buffer.from(account.data));
};
//# sourceMappingURL=gatekeeper.test.js.map