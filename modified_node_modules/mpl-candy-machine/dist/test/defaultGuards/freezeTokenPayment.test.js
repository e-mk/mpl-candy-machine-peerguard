"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const mpl_toolbox_1 = require("@metaplex-foundation/mpl-toolbox");
const mpl_token_metadata_1 = require("@metaplex-foundation/mpl-token-metadata");
const umi_1 = require("@metaplex-foundation/umi");
const ava_1 = __importDefault(require("ava"));
const src_1 = require("../../src");
const _setup_1 = require("../_setup");
(0, ava_1.default)('it transfers tokens to an escrow account and freezes the NFT', async (t) => {
    // Given a token mint with holders such that the identity has 10 tokens.
    const umi = await (0, _setup_1.createUmi)();
    const destination = (0, umi_1.generateSigner)(umi);
    const [tokenMint, destinationAta] = await (0, _setup_1.createMintWithHolders)(umi, {
        holders: [
            { owner: destination, amount: 0 },
            { owner: umi.identity, amount: 10 },
        ],
    });
    // And a loaded Candy Machine with a freezeTokenPayment guard.
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        configLines: [
            { name: 'Degen #1', uri: 'https://example.com/degen/1' },
            { name: 'Degen #2', uri: 'https://example.com/degen/2' },
        ],
        guards: {
            freezeTokenPayment: (0, umi_1.some)({
                mint: tokenMint.publicKey,
                destinationAta,
                amount: 1,
            }),
        },
    });
    // And given the freezeTokenPayment guard is initialized.
    await (0, umi_1.transactionBuilder)()
        .add((0, src_1.route)(umi, {
        candyMachine,
        guard: 'freezeTokenPayment',
        routeArgs: {
            path: 'initialize',
            period: 15 * 24 * 3600,
            candyGuardAuthority: umi.identity,
            mint: (0, umi_1.publicKey)(tokenMint),
            destinationAta,
        },
    }))
        .sendAndConfirm(umi);
    // When we mint from that candy machine.
    const mint = (0, umi_1.generateSigner)(umi);
    await (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 600000 }))
        .add((0, src_1.mintV2)(umi, {
        candyMachine,
        nftMint: mint,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
        mintArgs: {
            freezeTokenPayment: (0, umi_1.some)({
                mint: (0, umi_1.publicKey)(tokenMint),
                destinationAta,
            }),
        },
    }))
        .sendAndConfirm(umi);
    // Then minting was successful.
    await (0, _setup_1.assertSuccessfulMint)(t, umi, { mint, owner: umi.identity });
    // And the NFT is frozen.
    const ata = (0, mpl_toolbox_1.findAssociatedTokenPda)(umi, {
        mint: mint.publicKey,
        owner: umi.identity.publicKey,
    });
    const tokenAccount = await (0, mpl_toolbox_1.fetchToken)(umi, ata);
    t.is(tokenAccount.state, mpl_toolbox_1.TokenState.Frozen, 'NFT is frozen');
    // And cannot be thawed since not all NFTs have been minted.
    const cm = candyMachine;
    const promise = thawNft(umi, cm, tokenMint, destinationAta, mint.publicKey);
    await t.throwsAsync(promise, { message: /ThawNotEnabled/ });
    // And the treasury escrow received tokens.
    const freezeEscrow = getFreezeEscrow(umi, candyMachine, destinationAta);
    const escrowTokens = await getTokenBalance(umi, tokenMint, freezeEscrow);
    t.is(escrowTokens, 1, 'treasury escrow received tokens');
    // And was assigned the right data.
    const freezeEscrowAccount = await (0, src_1.fetchFreezeEscrow)(umi, freezeEscrow);
    t.true((0, umi_1.isSome)(freezeEscrowAccount.firstMintTime));
    t.like(freezeEscrowAccount, {
        candyMachine: (0, umi_1.publicKey)(candyMachine),
        candyGuard: (0, umi_1.publicKey)((0, src_1.findCandyGuardPda)(umi, { base: candyMachine })),
        frozenCount: 1n,
        freezePeriod: BigInt(15 * 24 * 3600),
        destination: (0, umi_1.publicKey)(destinationAta),
        authority: (0, umi_1.publicKey)(umi.identity),
    });
    // And the payer lost tokens.
    const payerBalance = await getTokenBalance(umi, tokenMint, umi.identity);
    t.is(payerBalance, 9, 'payer lost tokens');
});
(0, ava_1.default)('it allows minting even when the payer is different from the minter', async (t) => {
    // Given a token mint with holders such that an explicit minter has 10 tokens.
    const umi = await (0, _setup_1.createUmi)();
    const minter = (0, umi_1.generateSigner)(umi);
    const destination = (0, umi_1.generateSigner)(umi);
    const [tokenMint, destinationAta] = await (0, _setup_1.createMintWithHolders)(umi, {
        holders: [
            { owner: destination, amount: 0 },
            { owner: minter, amount: 10 },
        ],
    });
    // And a loaded Candy Machine with a freezeTokenPayment guard.
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        configLines: [
            { name: 'Degen #1', uri: 'https://example.com/degen/1' },
            { name: 'Degen #2', uri: 'https://example.com/degen/2' },
        ],
        guards: {
            freezeTokenPayment: (0, umi_1.some)({
                mint: tokenMint.publicKey,
                destinationAta,
                amount: 1,
            }),
        },
    });
    // And given the freezeTokenPayment guard is initialized.
    await initFreezeEscrow(umi, candyMachine, tokenMint, destinationAta);
    // When we mint from that candy machine using an explicit minter.
    const mint = (0, umi_1.generateSigner)(umi);
    await (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 600000 }))
        .add((0, src_1.mintV2)(umi, {
        candyMachine,
        nftMint: mint,
        minter,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
        mintArgs: {
            freezeTokenPayment: (0, umi_1.some)({
                mint: (0, umi_1.publicKey)(tokenMint),
                destinationAta,
            }),
        },
    }))
        .sendAndConfirm(umi);
    // Then minting was successful.
    await (0, _setup_1.assertSuccessfulMint)(t, umi, { mint, owner: minter });
});
(0, ava_1.default)('it allows minting when the mint and token accounts are created beforehand', async (t) => {
    // Given a token mint with holders such that the identity has 10 tokens.
    const umi = await (0, _setup_1.createUmi)();
    const destination = (0, umi_1.generateSigner)(umi);
    const [tokenMint, destinationAta] = await (0, _setup_1.createMintWithHolders)(umi, {
        holders: [
            { owner: destination, amount: 0 },
            { owner: umi.identity, amount: 10 },
        ],
    });
    // And a loaded Candy Machine with a freezeTokenPayment guard.
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        configLines: [
            { name: 'Degen #1', uri: 'https://example.com/degen/1' },
            { name: 'Degen #2', uri: 'https://example.com/degen/2' },
        ],
        guards: {
            freezeTokenPayment: (0, umi_1.some)({
                mint: tokenMint.publicKey,
                destinationAta,
                amount: 1,
            }),
        },
    });
    // And given the freezeTokenPayment guard is initialized.
    await initFreezeEscrow(umi, candyMachine, tokenMint, destinationAta);
    // When we mint from that candy machine by creating
    // the mint and token accounts beforehand.
    const mint = (0, umi_1.generateSigner)(umi);
    await (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 600000 }))
        .add((0, mpl_toolbox_1.createMintWithAssociatedToken)(umi, {
        mint,
        owner: umi.identity.publicKey,
    }))
        .add((0, src_1.mintV2)(umi, {
        candyMachine,
        nftMint: mint,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
        mintArgs: {
            freezeTokenPayment: (0, umi_1.some)({
                mint: (0, umi_1.publicKey)(tokenMint),
                destinationAta,
            }),
        },
    }))
        .sendAndConfirm(umi);
    // Then minting was successful.
    await (0, _setup_1.assertSuccessfulMint)(t, umi, { mint, owner: umi.identity });
});
(0, ava_1.default)('it can thaw an NFT once all NFTs are minted', async (t) => {
    // Given a token mint with holders such that the identity has 10 tokens.
    const umi = await (0, _setup_1.createUmi)();
    const destination = (0, umi_1.generateSigner)(umi);
    const [tokenMint, destinationAta] = await (0, _setup_1.createMintWithHolders)(umi, {
        holders: [
            { owner: destination, amount: 0 },
            { owner: umi.identity, amount: 10 },
        ],
    });
    // And a loaded Candy Machine with an initialized
    // freezeTokenPayment guard with only one item.
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        configLines: [{ name: 'Degen #1', uri: 'https://example.com/degen/1' }],
        guards: {
            freezeTokenPayment: (0, umi_1.some)({
                mint: tokenMint.publicKey,
                destinationAta,
                amount: 1,
            }),
        },
    });
    await initFreezeEscrow(umi, candyMachine, tokenMint, destinationAta);
    // And given we minted the only frozen NFT from that candy machine.
    const mint = await mintNft(umi, candyMachine, tokenMint, destinationAta, collectionMint);
    t.is(await getTokenState(umi, mint, umi.identity), mpl_toolbox_1.TokenState.Frozen);
    // When we thaw the NFT.
    await thawNft(umi, candyMachine, tokenMint, destinationAta, mint.publicKey);
    // Then the NFT is thawed.
    t.is(await getTokenState(umi, mint, umi.identity), mpl_toolbox_1.TokenState.Initialized);
});
(0, ava_1.default)('it can unlock funds once all NFTs have been thawed', async (t) => {
    // Given a token mint with holders such that the identity has 10 tokens.
    const umi = await (0, _setup_1.createUmi)();
    const destination = (0, umi_1.generateSigner)(umi);
    const [tokenMint, destinationAta] = await (0, _setup_1.createMintWithHolders)(umi, {
        holders: [
            { owner: destination, amount: 0 },
            { owner: umi.identity, amount: 10 },
        ],
    });
    // And a loaded Candy Machine with an initialized freezeTokenPayment guard.
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        configLines: [{ name: 'Degen #1', uri: 'https://example.com/degen/1' }],
        guards: {
            freezeTokenPayment: (0, umi_1.some)({
                mint: tokenMint.publicKey,
                destinationAta,
                amount: 1,
            }),
        },
    });
    await initFreezeEscrow(umi, candyMachine, tokenMint, destinationAta);
    // And given all NFTs have been minted and thawed.
    const mint = await mintNft(umi, candyMachine, tokenMint, destinationAta, collectionMint);
    await thawNft(umi, candyMachine, tokenMint, destinationAta, mint.publicKey);
    // When the authority unlocks the funds.
    await (0, umi_1.transactionBuilder)()
        .add((0, src_1.route)(umi, {
        candyMachine,
        guard: 'freezeTokenPayment',
        routeArgs: {
            path: 'unlockFunds',
            candyGuardAuthority: umi.identity,
            mint: (0, umi_1.publicKey)(tokenMint),
            destinationAta,
        },
    }))
        .sendAndConfirm(umi);
    // Then the destination wallet received the token.
    const treasuryBalance = await getTokenBalance(umi, tokenMint, destination);
    t.is(treasuryBalance, 1, 'treasury received tokens');
    // And the treasury escrow ATA no longer exists.
    const [treasuryEscrow] = getFreezeEscrow(umi, candyMachine, destinationAta);
    const [treasuryEscrowAta] = (0, mpl_toolbox_1.findAssociatedTokenPda)(umi, {
        mint: mint.publicKey,
        owner: treasuryEscrow,
    });
    t.false(await umi.rpc.accountExists(treasuryEscrowAta), 'treasury escrow ATA no longer exists');
});
(0, ava_1.default)('it cannot unlock funds if not all NFTs have been thawed', async (t) => {
    // Given a token mint with holders such that the identity has 10 tokens.
    const umi = await (0, _setup_1.createUmi)();
    const destination = (0, umi_1.generateSigner)(umi);
    const [tokenMint, destinationAta] = await (0, _setup_1.createMintWithHolders)(umi, {
        holders: [
            { owner: destination, amount: 0 },
            { owner: umi.identity, amount: 10 },
        ],
    });
    // And a loaded Candy Machine with an initialized freezeTokenPayment guard.
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        configLines: [{ name: 'Degen #1', uri: 'https://example.com/degen/1' }],
        guards: {
            freezeTokenPayment: (0, umi_1.some)({
                mint: tokenMint.publicKey,
                destinationAta,
                amount: 1,
            }),
        },
    });
    await initFreezeEscrow(umi, candyMachine, tokenMint, destinationAta);
    // And given all NFTs have been minted but not thawed.
    await mintNft(umi, candyMachine, tokenMint, destinationAta, collectionMint);
    // When the authority tries to unlock the funds.
    const promise = (0, umi_1.transactionBuilder)()
        .add((0, src_1.route)(umi, {
        candyMachine,
        guard: 'freezeTokenPayment',
        routeArgs: {
            path: 'unlockFunds',
            candyGuardAuthority: umi.identity,
            mint: (0, umi_1.publicKey)(tokenMint),
            destinationAta,
        },
    }))
        .sendAndConfirm(umi);
    // Then we expect an error.
    await t.throwsAsync(promise, { message: /UnlockNotEnabled/ });
    // And the destination wallet did not receive any tokens.
    const treasuryBalance = await getTokenBalance(umi, tokenMint, destination);
    t.is(treasuryBalance, 0, 'treasury received no tokens');
});
(0, ava_1.default)('it can have multiple freeze escrow and reuse the same ones', async (t) => {
    // Increase the timeout of this long test to 20 seconds.
    t.timeout(20000);
    // Given a loaded Candy Machine with 4 groups
    // containing freezeTokenPayment guards such that:
    // - Group A and Group B use the same destination (and thus freeze escrow).
    // - Group C uses a different destination than group A and B.
    // - Group D does not use a freezeTokenPayment guard at all.
    // And such that the identity has 10 tokens of each mint.
    const umi = await (0, _setup_1.createUmi)();
    const destinationAB = (0, umi_1.generateSigner)(umi);
    const destinationC = (0, umi_1.generateSigner)(umi);
    const destinationD = (0, umi_1.generateSigner)(umi);
    const [mintAB, destinationAtaAB] = await (0, _setup_1.createMintWithHolders)(umi, {
        holders: [
            { owner: destinationAB, amount: 0 },
            { owner: umi.identity, amount: 10 },
        ],
    });
    const [mintC, destinationAtaC] = await (0, _setup_1.createMintWithHolders)(umi, {
        holders: [
            { owner: destinationC, amount: 0 },
            { owner: umi.identity, amount: 10 },
        ],
    });
    const [mintD, destinationAtaD] = await (0, _setup_1.createMintWithHolders)(umi, {
        holders: [
            { owner: destinationD, amount: 0 },
            { owner: umi.identity, amount: 10 },
        ],
    });
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        itemsAvailable: 4,
        guards: {},
        groups: [
            {
                label: 'GROUPA',
                guards: {
                    freezeTokenPayment: (0, umi_1.some)({
                        amount: 1,
                        destinationAta: destinationAtaAB,
                        mint: mintAB.publicKey,
                    }),
                },
            },
            {
                label: 'GROUPB',
                guards: {
                    freezeTokenPayment: (0, umi_1.some)({
                        amount: 3,
                        destinationAta: destinationAtaAB,
                        mint: mintAB.publicKey,
                    }),
                },
            },
            {
                label: 'GROUPC',
                guards: {
                    freezeTokenPayment: (0, umi_1.some)({
                        amount: 5,
                        destinationAta: destinationAtaC,
                        mint: mintC.publicKey,
                    }),
                },
            },
            {
                label: 'GROUPD',
                guards: {
                    tokenPayment: (0, umi_1.some)({
                        amount: 7,
                        destinationAta: destinationAtaD,
                        mint: mintD.publicKey,
                    }),
                },
            },
        ],
    });
    await (0, umi_1.transactionBuilder)()
        .add((0, src_1.addConfigLines)(umi, {
        candyMachine,
        index: 0,
        configLines: [
            { name: 'Degen #1', uri: 'https://example.com/degen/1' },
            { name: 'Degen #2', uri: 'https://example.com/degen/2' },
            { name: 'Degen #3', uri: 'https://example.com/degen/3' },
            { name: 'Degen #4', uri: 'https://example.com/degen/4' },
        ],
    }))
        .sendAndConfirm(umi);
    // And given all freeze escrows have been initialized.
    const cm = candyMachine;
    await initFreezeEscrow(umi, cm, mintAB, destinationAtaAB, 'GROUPA');
    await initFreezeEscrow(umi, cm, mintC, destinationAtaC, 'GROUPC');
    // Note that trying to initialize the escrow for group B will fail
    // because it has already been initialized via group A.
    await t.throwsAsync(initFreezeEscrow(umi, cm, mintAB, destinationAtaAB, 'GROUPB'), { message: /FreezeEscrowAlreadyExists/ });
    // When we mint all 4 NFTs via each group.
    const cl = collectionMint;
    const nftA = await mintNft(umi, cm, mintAB, destinationAtaAB, cl, 'GROUPA'); // 1 AB token.
    const nftB = await mintNft(umi, cm, mintAB, destinationAtaAB, cl, 'GROUPB'); // 3 AB tokens.
    const nftC = await mintNft(umi, cm, mintC, destinationAtaC, cl, 'GROUPC'); // 5 C tokens.
    const nftD = (0, umi_1.generateSigner)(umi); // 7 D tokens.
    await (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 600000 }))
        .add((0, src_1.mintV2)(umi, {
        candyMachine,
        nftMint: nftD,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
        group: (0, umi_1.some)('GROUPD'),
        mintArgs: {
            tokenPayment: (0, umi_1.some)({
                mint: mintD.publicKey,
                destinationAta: destinationAtaD,
            }),
        },
    }))
        .sendAndConfirm(umi);
    // Then all NFTs except for group D have been frozen.
    const [tokenA, tokenB, tokenC, tokenD] = await Promise.all([nftA, nftB, nftC, nftD].map(({ publicKey: mint }) => (0, mpl_toolbox_1.fetchToken)(umi, (0, mpl_toolbox_1.findAssociatedTokenPda)(umi, { mint, owner: umi.identity.publicKey }))));
    t.is(tokenA.state, mpl_toolbox_1.TokenState.Frozen, 'NFT A is frozen');
    t.is(tokenB.state, mpl_toolbox_1.TokenState.Frozen, 'NFT B is frozen');
    t.is(tokenC.state, mpl_toolbox_1.TokenState.Frozen, 'NFT C is frozen');
    t.is(tokenD.state, mpl_toolbox_1.TokenState.Initialized, 'NFT D is not frozen');
    // And the treasury escrow received tokens.
    const escrowAB = getFreezeEscrow(umi, candyMachine, destinationAtaAB);
    const escrowC = getFreezeEscrow(umi, candyMachine, destinationAtaC);
    const escrowBalanceAB = await getTokenBalance(umi, mintAB, escrowAB);
    const escrowBalanceC = await getTokenBalance(umi, mintC, escrowC);
    t.is(escrowBalanceAB, 4, 'treasury AB escrow ATA received tokens');
    t.is(escrowBalanceC, 5, 'treasury C escrow ATA received tokens');
    // And the payer lost tokens.
    const payerTokensAB = await getTokenBalance(umi, mintAB, umi.identity);
    const payerTokensC = await getTokenBalance(umi, mintC, umi.identity);
    const payerTokensD = await getTokenBalance(umi, mintD, umi.identity);
    t.is(payerTokensAB, 10 - 4, 'payer lost AB tokens');
    t.is(payerTokensC, 10 - 5, 'payer lost C tokens');
    t.is(payerTokensD, 10 - 7, 'payer lost D tokens');
    // And the frozen counters securely decrease as we thaw all frozen NFTs.
    const assertFrozenCounts = async (ab, c) => {
        await Promise.all([
            assertFrozenCount(t, umi, candyMachine, destinationAtaAB, ab),
            assertFrozenCount(t, umi, candyMachine, destinationAtaC, c),
        ]);
    };
    await assertFrozenCounts(2, 1);
    await thawNft(umi, cm, mintAB, destinationAtaAB, nftD.publicKey, 'GROUPA'); // Not frozen.
    await assertFrozenCounts(2, 1); // No change.
    await thawNft(umi, cm, mintAB, destinationAtaAB, nftA.publicKey, 'GROUPA');
    await assertFrozenCounts(1, 1); // AB decreased.
    await thawNft(umi, cm, mintAB, destinationAtaAB, nftA.publicKey, 'GROUPA'); // Already thawed.
    await assertFrozenCounts(1, 1); // No change.
    await thawNft(umi, cm, mintAB, destinationAtaAB, nftB.publicKey, 'GROUPB');
    await assertFrozenCounts(0, 1); // AB decreased.
    await thawNft(umi, cm, mintC, destinationAtaC, nftC.publicKey, 'GROUPC');
    await assertFrozenCounts(0, 0); // C decreased.
    // And when the authority unlocks the funds of both freeze escrows.
    await unlockFunds(umi, cm, mintAB, destinationAtaAB, 'GROUPA');
    await unlockFunds(umi, cm, mintC, destinationAtaC, 'GROUPC');
    // Note that trying to unlock the funds of group B will fail
    // because it has already been unlocked via group A.
    await t.throwsAsync(unlockFunds(umi, cm, mintAB, destinationAtaAB, 'GROUPB'), { message: /AccountNotInitialized/ });
    // Then the treasuries received the funds.
    t.is(await getTokenBalance(umi, mintAB, destinationAB.publicKey), 4);
    t.is(await getTokenBalance(umi, mintC, destinationC.publicKey), 5);
    t.is(await getTokenBalance(umi, mintD, destinationD.publicKey), 7);
    // And the treasury escrows ATA no longer exist.
    const [escrowAtaAB] = (0, mpl_toolbox_1.findAssociatedTokenPda)(umi, {
        mint: mintAB.publicKey,
        owner: getFreezeEscrow(umi, candyMachine, destinationAtaAB)[0],
    });
    const [escrowAtaC] = (0, mpl_toolbox_1.findAssociatedTokenPda)(umi, {
        mint: mintC.publicKey,
        owner: getFreezeEscrow(umi, candyMachine, destinationAtaC)[0],
    });
    t.false(await umi.rpc.accountExists(escrowAtaAB), 'treasury AB escrow ATA no longer exists');
    t.false(await umi.rpc.accountExists(escrowAtaC), 'treasury C escrow ATA no longer exists');
});
(0, ava_1.default)('it fails to mint if the freeze escrow was not initialized', async (t) => {
    // Given a token mint with holders such that the identity has 10 tokens.
    const umi = await (0, _setup_1.createUmi)();
    const destination = (0, umi_1.generateSigner)(umi);
    const [tokenMint, destinationAta] = await (0, _setup_1.createMintWithHolders)(umi, {
        holders: [
            { owner: destination, amount: 0 },
            { owner: umi.identity, amount: 10 },
        ],
    });
    // And a loaded Candy Machine with a freezeTokenPayment guard.
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        configLines: [{ name: 'Degen #1', uri: 'https://example.com/degen/1' }],
        guards: {
            freezeTokenPayment: (0, umi_1.some)({
                mint: tokenMint.publicKey,
                destinationAta,
                amount: 1,
            }),
        },
    });
    // When we try to mint without initializing the freeze escrow.
    const mint = (0, umi_1.generateSigner)(umi);
    const promise = (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 600000 }))
        .add((0, mpl_toolbox_1.createMintWithAssociatedToken)(umi, {
        mint,
        owner: umi.identity.publicKey,
    }))
        .add((0, src_1.mintV2)(umi, {
        candyMachine,
        nftMint: mint,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
        mintArgs: {
            freezeTokenPayment: (0, umi_1.some)({
                mint: (0, umi_1.publicKey)(tokenMint),
                destinationAta,
            }),
        },
    }))
        .sendAndConfirm(umi);
    // Then we expect an error.
    await t.throwsAsync(promise, { message: /FreezeNotInitialized/ });
});
(0, ava_1.default)('it fails to mint if the payer does not have enough tokens', async (t) => {
    // Given a token mint with holders such that the identity has 4 tokens.
    const umi = await (0, _setup_1.createUmi)();
    const destination = (0, umi_1.generateSigner)(umi);
    const [tokenMint, destinationAta] = await (0, _setup_1.createMintWithHolders)(umi, {
        holders: [
            { owner: destination, amount: 0 },
            { owner: umi.identity, amount: 4 },
        ],
    });
    // And a loaded Candy Machine with an initialized
    // freezeTokenPayment guard costing 5 tokens.
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        configLines: [{ name: 'Degen #1', uri: 'https://example.com/degen/1' }],
        guards: {
            freezeTokenPayment: (0, umi_1.some)({
                mint: tokenMint.publicKey,
                destinationAta,
                amount: 5,
            }),
        },
    });
    await initFreezeEscrow(umi, candyMachine, tokenMint, destinationAta);
    // When the identity tries to mint from it.
    const mint = (0, umi_1.generateSigner)(umi);
    const promise = (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 600000 }))
        .add((0, mpl_toolbox_1.createMintWithAssociatedToken)(umi, {
        mint,
        owner: umi.identity.publicKey,
    }))
        .add((0, src_1.mintV2)(umi, {
        candyMachine,
        nftMint: mint,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
        mintArgs: {
            freezeTokenPayment: (0, umi_1.some)({
                mint: (0, umi_1.publicKey)(tokenMint),
                destinationAta,
            }),
        },
    }))
        .sendAndConfirm(umi);
    // Then we expect an error.
    await t.throwsAsync(promise, { message: /NotEnoughTokens/ });
});
(0, ava_1.default)('it charges a bot tax if something goes wrong', async (t) => {
    // Given a token mint with holders such that the identity has 10 tokens.
    const umi = await (0, _setup_1.createUmi)();
    const destination = (0, umi_1.generateSigner)(umi);
    const [tokenMint, destinationAta] = await (0, _setup_1.createMintWithHolders)(umi, {
        holders: [
            { owner: destination, amount: 0 },
            { owner: umi.identity, amount: 10 },
        ],
    });
    // And a loaded Candy Machine with a freezeTokenPayment guard and a bot tax guard.
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        configLines: [{ name: 'Degen #1', uri: 'https://example.com/degen/1' }],
        guards: {
            botTax: (0, umi_1.some)({ lamports: (0, umi_1.sol)(0.1), lastInstruction: true }),
            freezeTokenPayment: (0, umi_1.some)({
                mint: tokenMint.publicKey,
                destinationAta,
                amount: 1,
            }),
        },
    });
    // When we try to mint without initializing the freeze escrow.
    const mint = (0, umi_1.generateSigner)(umi);
    const { signature } = await (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 600000 }))
        .add((0, mpl_toolbox_1.createMintWithAssociatedToken)(umi, {
        mint,
        owner: umi.identity.publicKey,
    }))
        .add((0, src_1.mintV2)(umi, {
        candyMachine,
        nftMint: mint,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
        mintArgs: {
            freezeTokenPayment: (0, umi_1.some)({
                mint: (0, umi_1.publicKey)(tokenMint),
                destinationAta,
            }),
        },
    }))
        .sendAndConfirm(umi);
    // Then we expect a silent bot tax error.
    await (0, _setup_1.assertBotTax)(t, umi, mint, signature, /FreezeNotInitialized/);
});
(0, ava_1.default)('it transfers tokens to an escrow account and locks the Programmable NFT', async (t) => {
    // Given a token mint with holders such that the identity has 10 tokens.
    const umi = await (0, _setup_1.createUmi)();
    const destination = (0, umi_1.generateSigner)(umi);
    const [tokenMint, destinationAta] = await (0, _setup_1.createMintWithHolders)(umi, {
        holders: [
            { owner: destination, amount: 0 },
            { owner: umi.identity, amount: 10 },
        ],
    });
    // And a loaded PNFT Candy Machine with a freezeTokenPayment guard.
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        tokenStandard: mpl_token_metadata_1.TokenStandard.ProgrammableNonFungible,
        ruleSet: _setup_1.METAPLEX_DEFAULT_RULESET,
        collectionMint,
        configLines: [
            { name: 'Degen #1', uri: 'https://example.com/degen/1' },
            { name: 'Degen #2', uri: 'https://example.com/degen/2' },
        ],
        guards: {
            freezeTokenPayment: (0, umi_1.some)({
                mint: tokenMint.publicKey,
                destinationAta,
                amount: 1,
            }),
        },
    });
    // And given the freezeTokenPayment guard is initialized.
    await initFreezeEscrow(umi, candyMachine, tokenMint, destinationAta);
    // When we mint from that candy machine.
    const mint = (0, umi_1.generateSigner)(umi);
    await (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 800000 }))
        .add((0, src_1.mintV2)(umi, {
        candyMachine,
        nftMint: mint,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
        mintArgs: {
            freezeTokenPayment: (0, umi_1.some)({
                mint: tokenMint.publicKey,
                destinationAta,
                nftRuleSet: _setup_1.METAPLEX_DEFAULT_RULESET,
            }),
        },
        tokenStandard: mpl_token_metadata_1.TokenStandard.ProgrammableNonFungible,
        authorizationRulesProgram: (0, src_1.getMplTokenAuthRulesProgramId)(umi),
    }))
        .sendAndConfirm(umi);
    // Then minting was successful.
    await (0, _setup_1.assertSuccessfulMint)(t, umi, { mint, owner: umi.identity });
    // And the pNFT is frozen.
    const [ata] = (0, mpl_toolbox_1.findAssociatedTokenPda)(umi, {
        mint: mint.publicKey,
        owner: umi.identity.publicKey,
    });
    const tokenAccount = await (0, mpl_toolbox_1.fetchToken)(umi, ata);
    t.is(tokenAccount.state, mpl_toolbox_1.TokenState.Frozen);
    // And the token record is locked.
    const [tokenRecord] = (0, mpl_token_metadata_1.findTokenRecordPda)(umi, {
        mint: mint.publicKey,
        token: ata,
    });
    const tokenRecodAccount = await (0, mpl_token_metadata_1.fetchTokenRecord)(umi, tokenRecord);
    t.is(tokenRecodAccount.state, mpl_token_metadata_1.TokenState.Locked);
    // And cannot be thawed since not all NFTs have been minted.
    const promise = thawNft(umi, candyMachine, tokenMint, destinationAta, mint.publicKey);
    await t.throwsAsync(promise, { message: /ThawNotEnabled/ });
    // And the treasury escrow received tokens.
    const freezeEscrow = getFreezeEscrow(umi, candyMachine, destinationAta);
    const escrowTokens = await getTokenBalance(umi, tokenMint, freezeEscrow);
    t.is(escrowTokens, 1, 'treasury escrow received tokens');
    // And was assigned the right data.
    const freezeEscrowAccount = await (0, src_1.fetchFreezeEscrow)(umi, freezeEscrow);
    t.true((0, umi_1.isSome)(freezeEscrowAccount.firstMintTime));
    t.like(freezeEscrowAccount, {
        candyMachine: (0, umi_1.publicKey)(candyMachine),
        candyGuard: (0, umi_1.publicKey)((0, src_1.findCandyGuardPda)(umi, { base: candyMachine })),
        frozenCount: 1n,
        freezePeriod: BigInt(15 * 24 * 3600),
        destination: (0, umi_1.publicKey)(destinationAta),
        authority: (0, umi_1.publicKey)(umi.identity),
    });
    // And the payer lost tokens.
    const payerBalance = await getTokenBalance(umi, tokenMint, umi.identity);
    t.is(payerBalance, 9, 'payer lost tokens');
});
(0, ava_1.default)('it can thaw a Programmable NFT once all NFTs are minted', async (t) => {
    // Given a token mint with holders such that the identity has 10 tokens.
    const umi = await (0, _setup_1.createUmi)();
    const destination = (0, umi_1.generateSigner)(umi);
    const [tokenMint, destinationAta] = await (0, _setup_1.createMintWithHolders)(umi, {
        holders: [
            { owner: destination, amount: 0 },
            { owner: umi.identity, amount: 10 },
        ],
    });
    // And a loaded Candy Machine with a ruleSet and an initialized
    // freezeTokenPayment guard with only one item.
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        tokenStandard: mpl_token_metadata_1.TokenStandard.ProgrammableNonFungible,
        ruleSet: _setup_1.METAPLEX_DEFAULT_RULESET,
        configLines: [{ name: 'Degen #1', uri: 'https://example.com/degen/1' }],
        guards: {
            freezeTokenPayment: (0, umi_1.some)({
                mint: tokenMint.publicKey,
                destinationAta,
                amount: 1,
            }),
        },
    });
    await initFreezeEscrow(umi, candyMachine, tokenMint, destinationAta);
    // And given we minted the only PNFT from that candy machine.
    const mint = (0, umi_1.generateSigner)(umi);
    await (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 800000 }))
        .add((0, src_1.mintV2)(umi, {
        candyMachine,
        nftMint: mint,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
        mintArgs: {
            freezeTokenPayment: (0, umi_1.some)({
                mint: tokenMint.publicKey,
                destinationAta,
                nftRuleSet: _setup_1.METAPLEX_DEFAULT_RULESET,
            }),
        },
        tokenStandard: mpl_token_metadata_1.TokenStandard.ProgrammableNonFungible,
        authorizationRulesProgram: (0, src_1.getMplTokenAuthRulesProgramId)(umi),
    }))
        .sendAndConfirm(umi);
    // And that is it locked.
    const [tokenRecord] = (0, mpl_token_metadata_1.findTokenRecordPda)(umi, {
        mint: mint.publicKey,
        token: (0, mpl_toolbox_1.findAssociatedTokenPda)(umi, {
            mint: mint.publicKey,
            owner: umi.identity.publicKey,
        })[0],
    });
    let tokenRecordAccount = await (0, mpl_token_metadata_1.fetchTokenRecord)(umi, tokenRecord);
    t.is(tokenRecordAccount.state, mpl_token_metadata_1.TokenState.Locked);
    // When we thaw the locked PNFT.
    await (0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 600000 })
        .add((0, src_1.route)(umi, {
        candyMachine,
        guard: 'freezeTokenPayment',
        routeArgs: {
            path: 'thaw',
            nftMint: mint.publicKey,
            nftOwner: umi.identity.publicKey,
            nftTokenStandard: mpl_token_metadata_1.TokenStandard.ProgrammableNonFungible,
            mint: tokenMint.publicKey,
            destinationAta,
            nftRuleSet: _setup_1.METAPLEX_DEFAULT_RULESET,
        },
    }))
        .sendAndConfirm(umi);
    // Then the PNFT is unlocked.
    tokenRecordAccount = await (0, mpl_token_metadata_1.fetchTokenRecord)(umi, tokenRecord);
    t.is(tokenRecordAccount.state, mpl_token_metadata_1.TokenState.Unlocked);
    // And the freeze escrow ATA account is closed.
    t.false(await umi.rpc.accountExists((0, mpl_toolbox_1.findAssociatedTokenPda)(umi, {
        mint: mint.publicKey,
        owner: (0, src_1.findFreezeEscrowPda)(umi, {
            destination: destinationAta,
            candyMachine,
            candyGuard: (0, src_1.findCandyGuardPda)(umi, { base: candyMachine })[0],
        })[0],
    })[0]));
});
const getTokenBalance = async (umi, mint, owner) => {
    const ata = (0, mpl_toolbox_1.findAssociatedTokenPda)(umi, {
        mint: (0, umi_1.publicKey)(mint, false),
        owner: (0, umi_1.publicKey)(owner, false),
    });
    const tokenAccount = await (0, mpl_toolbox_1.fetchToken)(umi, ata);
    return Number(tokenAccount.amount);
};
const getTokenState = async (umi, mint, owner) => {
    const ata = (0, mpl_toolbox_1.findAssociatedTokenPda)(umi, {
        mint: (0, umi_1.publicKey)(mint, false),
        owner: (0, umi_1.publicKey)(owner, false),
    });
    const tokenAccount = await (0, mpl_toolbox_1.fetchToken)(umi, ata);
    return tokenAccount.state;
};
const getFreezeEscrow = (umi, candyMachine, destinationAta) => (0, src_1.findFreezeEscrowPda)(umi, {
    candyMachine,
    candyGuard: (0, src_1.findCandyGuardPda)(umi, { base: candyMachine })[0],
    destination: (0, umi_1.publicKey)(destinationAta, false),
});
const getFrozenCount = async (umi, candyMachine, destinationAta) => {
    const pda = getFreezeEscrow(umi, candyMachine, destinationAta);
    const account = await (0, src_1.fetchFreezeEscrow)(umi, pda);
    return Number(account.frozenCount);
};
const assertFrozenCount = async (t, umi, candyMachine, destinationAta, expected) => {
    const frozenCount = await getFrozenCount(umi, candyMachine, destinationAta);
    t.is(frozenCount, expected, 'frozen count is correct');
};
const initFreezeEscrow = async (umi, candyMachine, tokenMint, destinationAta, group) => {
    await (0, umi_1.transactionBuilder)()
        .add((0, src_1.route)(umi, {
        candyMachine,
        guard: 'freezeTokenPayment',
        group: group ? (0, umi_1.some)(group) : (0, umi_1.none)(),
        routeArgs: {
            path: 'initialize',
            period: 15 * 24 * 3600,
            candyGuardAuthority: umi.identity,
            mint: (0, umi_1.publicKey)(tokenMint),
            destinationAta: (0, umi_1.publicKey)(destinationAta),
        },
    }))
        .sendAndConfirm(umi);
};
const mintNft = async (umi, candyMachine, tokenMint, destinationAta, collectionMint, group) => {
    const mint = (0, umi_1.generateSigner)(umi);
    await (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 600000 }))
        .add((0, src_1.mintV2)(umi, {
        candyMachine,
        nftMint: mint,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
        group: group ? (0, umi_1.some)(group) : (0, umi_1.none)(),
        mintArgs: {
            freezeTokenPayment: (0, umi_1.some)({
                mint: (0, umi_1.publicKey)(tokenMint),
                destinationAta,
            }),
        },
    }))
        .sendAndConfirm(umi);
    return mint;
};
const thawNft = async (umi, candyMachine, tokenMint, destinationAta, nftMint, group, nftOwner) => {
    const candyMachineAccount = await (0, src_1.fetchCandyMachine)(umi, candyMachine);
    await (0, src_1.route)(umi, {
        candyMachine,
        guard: 'freezeTokenPayment',
        group: group ? (0, umi_1.some)(group) : (0, umi_1.none)(),
        routeArgs: {
            path: 'thaw',
            nftMint,
            nftOwner: nftOwner ?? umi.identity.publicKey,
            nftTokenStandard: candyMachineAccount.tokenStandard,
            mint: (0, umi_1.publicKey)(tokenMint),
            destinationAta,
        },
    }).sendAndConfirm(umi);
};
const unlockFunds = async (umi, candyMachine, tokenMint, destinationAta, group, candyGuardAuthority) => {
    await (0, src_1.route)(umi, {
        candyMachine,
        guard: 'freezeTokenPayment',
        group: group ? (0, umi_1.some)(group) : (0, umi_1.none)(),
        routeArgs: {
            path: 'unlockFunds',
            candyGuardAuthority: candyGuardAuthority ?? umi.identity,
            mint: (0, umi_1.publicKey)(tokenMint),
            destinationAta,
        },
    }).sendAndConfirm(umi);
};
//# sourceMappingURL=freezeTokenPayment.test.js.map