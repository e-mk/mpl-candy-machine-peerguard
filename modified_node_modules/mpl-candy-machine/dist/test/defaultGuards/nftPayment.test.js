"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const mpl_toolbox_1 = require("@metaplex-foundation/mpl-toolbox");
const mpl_token_metadata_1 = require("@metaplex-foundation/mpl-token-metadata");
const umi_1 = require("@metaplex-foundation/umi");
const ava_1 = __importDefault(require("ava"));
const src_1 = require("../../src");
const _setup_1 = require("../_setup");
(0, ava_1.default)('it transfers an NFT from the payer to the destination', async (t) => {
    // Given a loaded Candy Machine with an nftPayment guard on a required collection.
    const umi = await (0, _setup_1.createUmi)();
    const destination = (0, umi_1.generateSigner)(umi).publicKey;
    const requiredCollectionAuthority = (0, umi_1.generateSigner)(umi);
    const { publicKey: requiredCollection } = await (0, _setup_1.createCollectionNft)(umi, {
        authority: requiredCollectionAuthority,
    });
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        configLines: [{ name: 'Degen #1', uri: 'https://example.com/degen/1' }],
        guards: {
            nftPayment: (0, umi_1.some)({ requiredCollection, destination }),
        },
    });
    // And given the identity owns an NFT from that collection.
    const nftToSend = await (0, _setup_1.createVerifiedNft)(umi, {
        tokenOwner: umi.identity.publicKey,
        collectionMint: requiredCollection,
        collectionAuthority: requiredCollectionAuthority,
    });
    // When the payer mints from it using its NFT to pay.
    const mint = (0, umi_1.generateSigner)(umi);
    await (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 600000 }))
        .add((0, src_1.mintV2)(umi, {
        candyMachine,
        nftMint: mint,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
        mintArgs: {
            nftPayment: (0, umi_1.some)({
                tokenStandard: mpl_token_metadata_1.TokenStandard.NonFungible,
                requiredCollection,
                mint: nftToSend.publicKey,
                destination,
            }),
        },
    }))
        .sendAndConfirm(umi);
    // Then minting was successful.
    await (0, _setup_1.assertSuccessfulMint)(t, umi, { mint, owner: umi.identity });
    // And the NFT now belongs to the NFT destination.
    const updatedNft = await (0, mpl_token_metadata_1.fetchDigitalAssetWithAssociatedToken)(umi, nftToSend.publicKey, destination);
    t.deepEqual(updatedNft.token.owner, destination);
});
(0, ava_1.default)('it allows minting even when the payer is different from the minter', async (t) => {
    // Given a loaded Candy Machine with an nftPayment guard on a required collection.
    const umi = await (0, _setup_1.createUmi)();
    const destination = (0, umi_1.generateSigner)(umi).publicKey;
    const requiredCollectionAuthority = (0, umi_1.generateSigner)(umi);
    const { publicKey: requiredCollection } = await (0, _setup_1.createCollectionNft)(umi, {
        authority: requiredCollectionAuthority,
    });
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        configLines: [{ name: 'Degen #1', uri: 'https://example.com/degen/1' }],
        guards: {
            nftPayment: (0, umi_1.some)({ requiredCollection, destination }),
        },
    });
    // And given a separate minter owns an NFT from that collection.
    const minter = (0, umi_1.generateSigner)(umi);
    const nftToSend = await (0, _setup_1.createVerifiedNft)(umi, {
        tokenOwner: minter.publicKey,
        collectionMint: requiredCollection,
        collectionAuthority: requiredCollectionAuthority,
    });
    // When the minter mints from it using its NFT to pay.
    const mint = (0, umi_1.generateSigner)(umi);
    await (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 600000 }))
        .add((0, src_1.mintV2)(umi, {
        candyMachine,
        nftMint: mint,
        minter,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
        mintArgs: {
            nftPayment: (0, umi_1.some)({
                tokenStandard: mpl_token_metadata_1.TokenStandard.NonFungible,
                requiredCollection,
                mint: nftToSend.publicKey,
                destination,
            }),
        },
    }))
        .sendAndConfirm(umi);
    // Then minting was successful.
    await (0, _setup_1.assertSuccessfulMint)(t, umi, { mint, owner: minter });
    // And the NFT now belongs to the NFT destination.
    const updatedNft = await (0, mpl_token_metadata_1.fetchDigitalAssetWithAssociatedToken)(umi, nftToSend.publicKey, destination);
    t.deepEqual(updatedNft.token.owner, destination);
});
(0, ava_1.default)('it works when the provided NFT is not on an associated token account', async (t) => {
    // Given a loaded Candy Machine with an nftPayment guard on a required collection.
    const umi = await (0, _setup_1.createUmi)();
    const destination = (0, umi_1.generateSigner)(umi).publicKey;
    const requiredCollectionAuthority = (0, umi_1.generateSigner)(umi);
    const { publicKey: requiredCollection } = await (0, _setup_1.createCollectionNft)(umi, {
        authority: requiredCollectionAuthority,
    });
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        configLines: [{ name: 'Degen #1', uri: 'https://example.com/degen/1' }],
        guards: {
            nftPayment: (0, umi_1.some)({ requiredCollection, destination }),
        },
    });
    // And a payer that owns an NFT from that collection
    // but not on an associated token account.
    const nftToSend = (0, umi_1.generateSigner)(umi);
    const nftToSendToken = (0, umi_1.generateSigner)(umi);
    await (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.createMint)(umi, { mint: nftToSend }))
        .add((0, mpl_toolbox_1.createToken)(umi, {
        mint: nftToSend.publicKey,
        owner: umi.identity.publicKey,
        token: nftToSendToken,
    }))
        .sendAndConfirm(umi);
    await (0, _setup_1.createVerifiedNft)(umi, {
        mint: nftToSend,
        tokenOwner: umi.identity.publicKey,
        token: nftToSendToken.publicKey,
        collectionMint: requiredCollection,
        collectionAuthority: requiredCollectionAuthority,
    });
    // When the payer mints from it using its NFT to pay
    // whilst providing the token address.
    const mint = (0, umi_1.generateSigner)(umi);
    await (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 600000 }))
        .add((0, src_1.mintV2)(umi, {
        candyMachine,
        nftMint: mint,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
        mintArgs: {
            nftPayment: (0, umi_1.some)({
                tokenStandard: mpl_token_metadata_1.TokenStandard.NonFungible,
                requiredCollection,
                mint: nftToSend.publicKey,
                destination,
                tokenAccount: nftToSendToken.publicKey,
            }),
        },
    }))
        .sendAndConfirm(umi);
    // Then minting was successful.
    await (0, _setup_1.assertSuccessfulMint)(t, umi, { mint, owner: umi.identity });
    // And the NFT now belongs to the NFT destination.
    const updatedNft = await (0, mpl_token_metadata_1.fetchDigitalAssetWithAssociatedToken)(umi, nftToSend.publicKey, destination);
    t.deepEqual(updatedNft.token.owner, destination);
});
(0, ava_1.default)('it fails if the payer does not own the right NFT', async (t) => {
    // Given a loaded Candy Machine with an nftPayment guard on a required collection.
    const umi = await (0, _setup_1.createUmi)();
    const destination = (0, umi_1.generateSigner)(umi).publicKey;
    const requiredCollectionAuthority = (0, umi_1.generateSigner)(umi);
    const { publicKey: requiredCollection } = await (0, _setup_1.createCollectionNft)(umi, {
        authority: requiredCollectionAuthority,
    });
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        configLines: [{ name: 'Degen #1', uri: 'https://example.com/degen/1' }],
        guards: {
            nftPayment: (0, umi_1.some)({ requiredCollection, destination }),
        },
    });
    // And given the identity owns an NFT this is not from that collection.
    const wrongNft = await (0, _setup_1.createNft)(umi, {
        tokenOwner: umi.identity.publicKey,
    });
    // When the identity tries to mint from it using its NFT to pay.
    const mint = (0, umi_1.generateSigner)(umi);
    const promise = (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 600000 }))
        .add((0, src_1.mintV2)(umi, {
        candyMachine,
        nftMint: mint,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
        mintArgs: {
            nftPayment: (0, umi_1.some)({
                tokenStandard: mpl_token_metadata_1.TokenStandard.NonFungible,
                requiredCollection,
                mint: wrongNft.publicKey,
                destination,
            }),
        },
    }))
        .sendAndConfirm(umi);
    // Then we expect an error.
    await t.throwsAsync(promise, { message: /InvalidNftCollection/ });
});
(0, ava_1.default)('it fails if the payer tries to provide an NFT from an unverified collection', async (t) => {
    // Given a loaded Candy Machine with an nftPayment guard on a required collection.
    const umi = await (0, _setup_1.createUmi)();
    const destination = (0, umi_1.generateSigner)(umi).publicKey;
    const requiredCollectionAuthority = (0, umi_1.generateSigner)(umi);
    const { publicKey: requiredCollection } = await (0, _setup_1.createCollectionNft)(umi, {
        authority: requiredCollectionAuthority,
    });
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        configLines: [{ name: 'Degen #1', uri: 'https://example.com/degen/1' }],
        guards: {
            nftPayment: (0, umi_1.some)({ requiredCollection, destination }),
        },
    });
    // And given the identity owns an unverified NFT from that collection.
    const unverifiedNftToSend = await (0, _setup_1.createNft)(umi, {
        tokenOwner: umi.identity.publicKey,
        collection: (0, umi_1.some)({ key: requiredCollection, verified: false }),
    });
    // When the identity tries to mint from it using its NFT to pay.
    const mint = (0, umi_1.generateSigner)(umi);
    const promise = (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 600000 }))
        .add((0, src_1.mintV2)(umi, {
        candyMachine,
        nftMint: mint,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
        mintArgs: {
            nftPayment: (0, umi_1.some)({
                tokenStandard: mpl_token_metadata_1.TokenStandard.NonFungible,
                requiredCollection,
                mint: unverifiedNftToSend.publicKey,
                destination,
            }),
        },
    }))
        .sendAndConfirm(umi);
    // Then we expect an error.
    await t.throwsAsync(promise, { message: /InvalidNftCollection/ });
});
(0, ava_1.default)('it charges a bot tax when trying to pay with the wrong NFT', async (t) => {
    // Given a loaded Candy Machine with an nftPayment guard on a required collection and a bot tax.
    const umi = await (0, _setup_1.createUmi)();
    const destination = (0, umi_1.generateSigner)(umi).publicKey;
    const requiredCollectionAuthority = (0, umi_1.generateSigner)(umi);
    const { publicKey: requiredCollection } = await (0, _setup_1.createCollectionNft)(umi, {
        authority: requiredCollectionAuthority,
    });
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        configLines: [{ name: 'Degen #1', uri: 'https://example.com/degen/1' }],
        guards: {
            botTax: (0, umi_1.some)({ lamports: (0, umi_1.sol)(0.1), lastInstruction: true }),
            nftPayment: (0, umi_1.some)({ requiredCollection, destination }),
        },
    });
    // And given the identity owns an NFT this is not from that collection.
    const wrongNft = await (0, _setup_1.createNft)(umi, {
        tokenOwner: umi.identity.publicKey,
    });
    // When the identity tries to mint from it using its NFT to pay.
    const mint = (0, umi_1.generateSigner)(umi);
    const { signature } = await (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 600000 }))
        .add((0, src_1.mintV2)(umi, {
        candyMachine,
        nftMint: mint,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
        mintArgs: {
            nftPayment: (0, umi_1.some)({
                tokenStandard: mpl_token_metadata_1.TokenStandard.NonFungible,
                requiredCollection,
                mint: wrongNft.publicKey,
                destination,
            }),
        },
    }))
        .sendAndConfirm(umi);
    // Then we expect a bot tax error.
    await (0, _setup_1.assertBotTax)(t, umi, mint, signature, /InvalidNftCollection/);
});
(0, ava_1.default)('it transfers a Programmable NFT from the payer to the destination', async (t) => {
    // Given a loaded Candy Machine with an nftPayment guard on a required collection.
    const umi = await (0, _setup_1.createUmi)();
    const destination = (0, umi_1.generateSigner)(umi).publicKey;
    const requiredCollectionAuthority = (0, umi_1.generateSigner)(umi);
    const { publicKey: requiredCollection } = await (0, _setup_1.createCollectionNft)(umi, {
        authority: requiredCollectionAuthority,
    });
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        configLines: [{ name: 'Degen #1', uri: 'https://example.com/degen/1' }],
        guards: {
            nftPayment: (0, umi_1.some)({ requiredCollection, destination }),
        },
    });
    // And given the identity owns a Programmable NFT from that collection.
    const pnftToSend = await (0, _setup_1.createVerifiedProgrammableNft)(umi, {
        tokenOwner: umi.identity.publicKey,
        collectionMint: requiredCollection,
        collectionAuthority: requiredCollectionAuthority,
        ruleSet: (0, umi_1.some)((0, umi_1.publicKey)('eBJLFYPxJmMGKuFwpDWkzxZeUrad92kZRC5BJLpzyT9')),
    });
    // When the payer mints from it using its NFT to pay.
    const mint = (0, umi_1.generateSigner)(umi);
    await (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 800000 }))
        .add((0, src_1.mintV2)(umi, {
        candyMachine,
        nftMint: mint,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
        mintArgs: {
            nftPayment: (0, umi_1.some)({
                tokenStandard: mpl_token_metadata_1.TokenStandard.ProgrammableNonFungible,
                requiredCollection,
                mint: pnftToSend.publicKey,
                destination,
                ruleSet: (0, umi_1.publicKey)('eBJLFYPxJmMGKuFwpDWkzxZeUrad92kZRC5BJLpzyT9'),
            }),
        },
    }))
        .sendAndConfirm(umi);
    // Then minting was successful.
    await (0, _setup_1.assertSuccessfulMint)(t, umi, { mint, owner: umi.identity });
    // And the NFT now belongs to the NFT destination.
    const updatedNft = await (0, mpl_token_metadata_1.fetchDigitalAssetWithAssociatedToken)(umi, pnftToSend.publicKey, destination);
    t.deepEqual(updatedNft.token.owner, destination);
    t.like(updatedNft.metadata, {
        tokenStandard: (0, umi_1.some)(mpl_token_metadata_1.TokenStandard.ProgrammableNonFungible),
    });
});
//# sourceMappingURL=nftPayment.test.js.map