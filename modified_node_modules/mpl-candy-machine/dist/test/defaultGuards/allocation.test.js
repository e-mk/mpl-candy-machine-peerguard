"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const mpl_toolbox_1 = require("@metaplex-foundation/mpl-toolbox");
const umi_1 = require("@metaplex-foundation/umi");
const ava_1 = __importDefault(require("ava"));
const src_1 = require("../../src");
const _setup_1 = require("../_setup");
(0, ava_1.default)('it allows minting when the allocation limit is not reached', async (t) => {
    // Given a loaded Candy Machine with an allocation limit of 5.
    const umi = await (0, _setup_1.createUmi)();
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        configLines: [
            { name: 'Degen #1', uri: 'https://example.com/degen/1' },
            { name: 'Degen #2', uri: 'https://example.com/degen/2' },
        ],
        guards: {
            allocation: (0, umi_1.some)({ id: 1, limit: 5 }),
        },
    });
    // And initialize the allocation PDA.
    await (0, umi_1.transactionBuilder)()
        .add((0, src_1.route)(umi, {
        candyMachine,
        guard: 'allocation',
        routeArgs: {
            id: 1,
            candyGuardAuthority: umi.identity,
        },
    }))
        .sendAndConfirm(umi);
    // When we mint from it.
    const mint = (0, umi_1.generateSigner)(umi);
    await (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 600000 }))
        .add((0, src_1.mintV2)(umi, {
        candyMachine,
        nftMint: mint,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
        mintArgs: { allocation: (0, umi_1.some)({ id: 1 }) },
    }))
        .sendAndConfirm(umi);
    // Then minting was successful.
    await (0, _setup_1.assertSuccessfulMint)(t, umi, { mint, owner: umi.identity });
    // And the mint tracker PDA was incremented.
    const trackerPda = (0, src_1.findAllocationTrackerPda)(umi, {
        id: 1,
        candyMachine,
        candyGuard: (0, src_1.findCandyGuardPda)(umi, { base: candyMachine })[0],
    });
    const trackerPdaAccount = await (0, src_1.fetchAllocationTracker)(umi, trackerPda);
    t.is(trackerPdaAccount.count, 1);
});
(0, ava_1.default)('it forbids minting when the allocation limit is reached', async (t) => {
    // Given a loaded Candy Machine with an allocation limit of 1.
    const umi = await (0, _setup_1.createUmi)();
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        configLines: [
            { name: 'Degen #1', uri: 'https://example.com/degen/1' },
            { name: 'Degen #2', uri: 'https://example.com/degen/2' },
        ],
        guards: {
            allocation: (0, umi_1.some)({ id: 1, limit: 1 }),
        },
    });
    // And initialize the allocation PDA.
    await (0, umi_1.transactionBuilder)()
        .add((0, src_1.route)(umi, {
        candyMachine,
        guard: 'allocation',
        routeArgs: {
            id: 1,
            candyGuardAuthority: umi.identity,
        },
    }))
        .sendAndConfirm(umi);
    // And we already minted from it.
    const mint = (0, umi_1.generateSigner)(umi);
    await (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 600000 }))
        .add((0, src_1.mintV2)(umi, {
        candyMachine,
        nftMint: mint,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
        mintArgs: { allocation: (0, umi_1.some)({ id: 1 }) },
    }))
        .sendAndConfirm(umi);
    // When we try to mint again.
    const promise = (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 600000 }))
        .add((0, src_1.mintV2)(umi, {
        candyMachine,
        nftMint: mint,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
        mintArgs: { allocation: (0, umi_1.some)({ id: 1 }) },
    }))
        .sendAndConfirm(umi);
    // Then we expect an error.
    await t.throwsAsync(promise, { message: /Allocation limit was reached/ });
});
(0, ava_1.default)('the allocation limit is local to each id', async (t) => {
    // Given a loaded Candy Machine with two allocation limits of 1.
    const umi = await (0, _setup_1.createUmi)();
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        configLines: [
            { name: 'Degen #1', uri: 'https://example.com/degen/1' },
            { name: 'Degen #2', uri: 'https://example.com/degen/2' },
        ],
        guards: {},
        groups: [
            {
                label: 'GROUPA',
                guards: {
                    allocation: (0, umi_1.some)({ id: 1, limit: 1 }),
                },
            },
            {
                label: 'GROUPB',
                guards: {
                    allocation: (0, umi_1.some)({ id: 2, limit: 1 }),
                },
            },
        ],
    });
    // And initialize the allocation PDA.
    await (0, umi_1.transactionBuilder)()
        .add((0, src_1.route)(umi, {
        candyMachine,
        guard: 'allocation',
        routeArgs: {
            id: 1,
            candyGuardAuthority: umi.identity,
        },
        group: (0, umi_1.some)('GROUPA'),
    }))
        .add((0, src_1.route)(umi, {
        candyMachine,
        guard: 'allocation',
        routeArgs: {
            id: 2,
            candyGuardAuthority: umi.identity,
        },
        group: (0, umi_1.some)('GROUPB'),
    }))
        .sendAndConfirm(umi);
    // And minter A already minted their NFT.
    const minterA = (0, umi_1.generateSigner)(umi);
    const mintA = (0, umi_1.generateSigner)(umi);
    await (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 600000 }))
        .add((0, src_1.mintV2)(umi, {
        candyMachine,
        nftMint: mintA,
        minter: minterA,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
        mintArgs: { allocation: (0, umi_1.some)({ id: 1 }) },
        group: (0, umi_1.some)('GROUPA'),
    }))
        .sendAndConfirm(umi);
    await (0, _setup_1.assertSuccessfulMint)(t, umi, { mint: mintA, owner: minterA });
    // When minter B mints from the same Candy Machine but from a different group.
    const minterB = (0, umi_1.generateSigner)(umi);
    const mintB = (0, umi_1.generateSigner)(umi);
    await (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 600000 }))
        .add((0, src_1.mintV2)(umi, {
        candyMachine,
        nftMint: mintB,
        minter: minterB,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
        mintArgs: { allocation: (0, umi_1.some)({ id: 2 }) },
        group: (0, umi_1.some)('GROUPB'),
    }))
        .sendAndConfirm(umi);
    // Then minting was successful as the limit is per id.
    await (0, _setup_1.assertSuccessfulMint)(t, umi, { mint: mintB, owner: minterB });
});
(0, ava_1.default)('it charges a bot tax when trying to mint after the limit', async (t) => {
    // Given a loaded Candy Machine with an allocation limit of 1 and a bot tax guard.
    const umi = await (0, _setup_1.createUmi)();
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        configLines: [
            { name: 'Degen #1', uri: 'https://example.com/degen/1' },
            { name: 'Degen #2', uri: 'https://example.com/degen/2' },
        ],
        guards: {
            botTax: (0, umi_1.some)({ lamports: (0, umi_1.sol)(0.1), lastInstruction: true }),
            allocation: (0, umi_1.some)({ id: 1, limit: 1 }),
        },
    });
    // And initialize the allocation PDA.
    await (0, umi_1.transactionBuilder)()
        .add((0, src_1.route)(umi, {
        candyMachine,
        guard: 'allocation',
        routeArgs: {
            id: 1,
            candyGuardAuthority: umi.identity,
        },
    }))
        .sendAndConfirm(umi);
    // And the identity already minted their NFT.
    const mintA = (0, umi_1.generateSigner)(umi);
    await (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 600000 }))
        .add((0, src_1.mintV2)(umi, {
        candyMachine,
        nftMint: mintA,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
        mintArgs: { allocation: (0, umi_1.some)({ id: 1 }) },
    }))
        .sendAndConfirm(umi);
    // When the identity tries to mint from the same Candy Machine again.
    const mintB = (0, umi_1.generateSigner)(umi);
    const { signature } = await (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 600000 }))
        .add((0, src_1.mintV2)(umi, {
        candyMachine,
        nftMint: mintB,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
        mintArgs: { allocation: (0, umi_1.some)({ id: 1 }) },
    }))
        .sendAndConfirm(umi);
    // Then we expect a bot tax error.
    await (0, _setup_1.assertBotTax)(t, umi, mintB, signature, /Allocation limit was reached/);
});
//# sourceMappingURL=allocation.test.js.map