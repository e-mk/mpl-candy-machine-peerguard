"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const umi_1 = require("@metaplex-foundation/umi");
const ava_1 = __importDefault(require("ava"));
const src_1 = require("../src");
const _setup_1 = require("./_setup");
(0, ava_1.default)('it can create a candy machine with an associated candy guard', async (t) => {
    // Given an existing collection NFT.
    const umi = await (0, _setup_1.createUmi)();
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    // When we create a new candy machine with an associated candy guard.
    const candyMachine = (0, umi_1.generateSigner)(umi);
    const destination = (0, umi_1.generateSigner)(umi).publicKey;
    const createInstructions = await (0, src_1.create)(umi, {
        candyMachine,
        collectionMint,
        guards: {
            botTax: (0, umi_1.some)({ lamports: (0, umi_1.sol)(0.01), lastInstruction: true }),
            solPayment: (0, umi_1.some)({ lamports: (0, umi_1.sol)(2), destination }),
        },
        ...(0, _setup_1.defaultCandyMachineData)(umi),
    });
    await (0, umi_1.transactionBuilder)().add(createInstructions).sendAndConfirm(umi);
    // Then we created a new candy guard derived from the candy machine's address.
    const candyGuard = (0, src_1.findCandyGuardPda)(umi, { base: candyMachine.publicKey });
    const candyGuardAccount = await (0, src_1.fetchCandyGuard)(umi, candyGuard);
    t.like(candyGuardAccount, {
        publicKey: (0, umi_1.publicKey)(candyGuard),
        base: (0, umi_1.publicKey)(candyMachine),
        authority: (0, umi_1.publicKey)(umi.identity),
        guards: {
            ...src_1.emptyDefaultGuardSetArgs,
            botTax: (0, umi_1.some)({ lamports: (0, umi_1.sol)(0.01), lastInstruction: true }),
            solPayment: (0, umi_1.some)({ lamports: (0, umi_1.sol)(2), destination }),
        },
        groups: [],
    });
    // And the created candy machine uses it as a mint authority.
    const candyMachineAccount = await (0, src_1.fetchCandyMachine)(umi, candyMachine.publicKey);
    t.like(candyMachineAccount, {
        publicKey: (0, umi_1.publicKey)(candyMachine),
        authority: (0, umi_1.publicKey)(umi.identity),
        mintAuthority: (0, umi_1.publicKey)(candyGuard),
    });
});
//# sourceMappingURL=create.test.js.map