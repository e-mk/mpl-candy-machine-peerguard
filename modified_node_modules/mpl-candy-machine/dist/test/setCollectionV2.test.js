"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const umi_1 = require("@metaplex-foundation/umi");
const ava_1 = __importDefault(require("ava"));
const mpl_token_metadata_1 = require("@metaplex-foundation/mpl-token-metadata");
const src_1 = require("../src");
const _setup_1 = require("./_setup");
const mpl_toolbox_1 = require("@metaplex-foundation/mpl-toolbox");
(0, ava_1.default)('it can update the collection of a candy machine v2', async (t) => {
    // Given a Candy Machine associated with Collection A.
    const umi = await (0, _setup_1.createUmi)();
    const collectionUpdateAuthorityA = (0, umi_1.generateSigner)(umi);
    const collectionA = await (0, _setup_1.createCollectionNft)(umi, {
        authority: collectionUpdateAuthorityA,
    });
    const candyMachine = await (0, _setup_1.createV2)(umi, {
        collectionMint: collectionA.publicKey,
        collectionUpdateAuthority: collectionUpdateAuthorityA,
    });
    // When we update its collection to Collection B.
    const collectionUpdateAuthorityB = (0, umi_1.generateSigner)(umi);
    const collectionB = await (0, _setup_1.createCollectionNft)(umi, {
        authority: collectionUpdateAuthorityB,
    });
    await (0, src_1.setCollectionV2)(umi, {
        candyMachine: candyMachine.publicKey,
        collectionMint: collectionA.publicKey,
        collectionUpdateAuthority: collectionUpdateAuthorityA.publicKey,
        newCollectionMint: collectionB.publicKey,
        newCollectionUpdateAuthority: collectionUpdateAuthorityB,
    }).sendAndConfirm(umi);
    // Then the Candy Machine's collection was updated accordingly.
    const candyMachineAccount = await (0, src_1.fetchCandyMachine)(umi, candyMachine.publicKey);
    t.like(candyMachineAccount, {
        collectionMint: (0, umi_1.publicKey)(collectionB.publicKey),
    });
});
(0, ava_1.default)('it can update the collection of a candy machine v1', async (t) => {
    // Given a Candy Machine associated with Collection A.
    const umi = await (0, _setup_1.createUmi)();
    const collectionUpdateAuthorityA = (0, umi_1.generateSigner)(umi);
    const collectionA = await (0, _setup_1.createCollectionNft)(umi, {
        authority: collectionUpdateAuthorityA,
    });
    const candyMachine = await (0, _setup_1.createV1)(umi, {
        collectionMint: collectionA.publicKey,
        collectionUpdateAuthority: collectionUpdateAuthorityA,
    });
    // When we update its collection to Collection B from a V1 Candy Machine.
    const collectionUpdateAuthorityB = (0, umi_1.generateSigner)(umi);
    const collectionB = await (0, _setup_1.createCollectionNft)(umi, {
        authority: collectionUpdateAuthorityB,
    });
    await (0, src_1.setCollectionV2)(umi, {
        candyMachine: candyMachine.publicKey,
        collectionMint: collectionA.publicKey,
        collectionUpdateAuthority: collectionUpdateAuthorityA.publicKey,
        // We have to explicitly provide the collection authority record
        // because v2 defaults to the new way of deriving delegate records.
        collectionDelegateRecord: (0, mpl_token_metadata_1.findCollectionAuthorityRecordPda)(umi, {
            mint: collectionA.publicKey,
            collectionAuthority: (0, src_1.findCandyMachineAuthorityPda)(umi, {
                candyMachine: candyMachine.publicKey,
            })[0],
        }),
        newCollectionMint: collectionB.publicKey,
        newCollectionUpdateAuthority: collectionUpdateAuthorityB,
    }).sendAndConfirm(umi);
    // Then the Candy Machine's collection was updated accordingly and
    // the version was upgraded to V2.
    const candyMachineAccount = await (0, src_1.fetchCandyMachine)(umi, candyMachine.publicKey);
    t.like(candyMachineAccount, {
        collectionMint: (0, umi_1.publicKey)(collectionB.publicKey),
        version: src_1.AccountVersion.V2,
    });
});
(0, ava_1.default)('it cannot update the collection of a candy machine when mint is in progress', async (t) => {
    // Given a Candy Machine associated with Collection A.
    const umi = await (0, _setup_1.createUmi)();
    const collectionUpdateAuthorityA = umi.identity;
    const collectionA = await (0, _setup_1.createCollectionNft)(umi);
    const candyMachine = await (0, _setup_1.createV2)(umi, {
        collectionMint: collectionA.publicKey,
        collectionUpdateAuthority: collectionUpdateAuthorityA,
        configLines: [
            { name: 'Degen #1', uri: 'https://example.com/degen/1' },
            { name: 'Degen #2', uri: 'https://example.com/degen/2' },
        ],
    });
    // And we mint an NFT from the candy machine.
    const mint = (0, umi_1.generateSigner)(umi);
    const owner = (0, umi_1.generateSigner)(umi).publicKey;
    await (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 400000 }))
        .add((0, src_1.mintFromCandyMachineV2)(umi, {
        candyMachine: (0, umi_1.publicKey)(candyMachine),
        mintAuthority: umi.identity,
        nftOwner: owner,
        nftMint: mint,
        collectionMint: (0, umi_1.publicKey)(collectionA),
        collectionUpdateAuthority: (0, umi_1.publicKey)(collectionUpdateAuthorityA),
    }))
        .sendAndConfirm(umi);
    // When we try to update its collection to Collection B.
    const collectionUpdateAuthorityB = (0, umi_1.generateSigner)(umi);
    const collectionB = await (0, _setup_1.createCollectionNft)(umi, {
        authority: collectionUpdateAuthorityB,
    });
    const promise = (0, src_1.setCollectionV2)(umi, {
        candyMachine: candyMachine.publicKey,
        collectionMint: collectionA.publicKey,
        collectionUpdateAuthority: collectionUpdateAuthorityA.publicKey,
        newCollectionMint: collectionB.publicKey,
        newCollectionUpdateAuthority: collectionUpdateAuthorityB,
    }).sendAndConfirm(umi);
    // Then we expect a client error.
    await t.throwsAsync(promise, {
        name: 'NoChangingCollectionDuringMint',
    });
});
ava_1.default.only('it can set the same collection of a candy machine when mint is in progress', async (t) => {
    // Given a Candy Machine associated with Collection A.
    const umi = await (0, _setup_1.createUmi)();
    const collectionUpdateAuthorityA = umi.identity;
    const collectionA = await (0, _setup_1.createCollectionNft)(umi);
    const candyMachine = await (0, _setup_1.createV2)(umi, {
        collectionMint: collectionA.publicKey,
        collectionUpdateAuthority: collectionUpdateAuthorityA,
        configLines: [
            { name: 'Degen #1', uri: 'https://example.com/degen/1' },
            { name: 'Degen #2', uri: 'https://example.com/degen/2' },
        ],
    });
    // And we mint an NFT from the candy machine.
    const mint = (0, umi_1.generateSigner)(umi);
    const owner = (0, umi_1.generateSigner)(umi).publicKey;
    await (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 400000 }))
        .add((0, src_1.mintFromCandyMachineV2)(umi, {
        candyMachine: (0, umi_1.publicKey)(candyMachine),
        mintAuthority: umi.identity,
        nftOwner: owner,
        nftMint: mint,
        collectionMint: (0, umi_1.publicKey)(collectionA),
        collectionUpdateAuthority: (0, umi_1.publicKey)(collectionUpdateAuthorityA),
    }))
        .sendAndConfirm(umi);
    // And we update the collection update authority to Authority B.
    const collectionUpdateAuthorityB = (0, umi_1.generateSigner)(umi);
    await (0, mpl_token_metadata_1.updateV1)(umi, {
        mint: collectionA.publicKey,
        newUpdateAuthority: collectionUpdateAuthorityB.publicKey,
    }).sendAndConfirm(umi);
    // When we set the same collection.
    await (0, src_1.setCollectionV2)(umi, {
        candyMachine: candyMachine.publicKey,
        collectionMint: collectionA.publicKey,
        collectionUpdateAuthority: collectionUpdateAuthorityA.publicKey,
        newCollectionMint: collectionA.publicKey,
        newCollectionUpdateAuthority: collectionUpdateAuthorityB,
    }).sendAndConfirm(umi);
    // Then the transaction suceeds and the Candy Machine collection is still the same.
    const candyMachineAccount = await (0, src_1.fetchCandyMachine)(umi, candyMachine.publicKey);
    t.like(candyMachineAccount, {
        collectionMint: (0, umi_1.publicKey)(collectionA.publicKey),
    });
});
//# sourceMappingURL=setCollectionV2.test.js.map