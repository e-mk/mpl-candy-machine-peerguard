"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const umi_1 = require("@metaplex-foundation/umi");
const ava_1 = __importDefault(require("ava"));
const src_1 = require("../src");
const _setup_1 = require("./_setup");
(0, ava_1.default)('it can update the guards of a candy guard', async (t) => {
    // Given an existing candy guard.
    const umi = await (0, _setup_1.createUmi)();
    const treasuryA = (0, umi_1.generateSigner)(umi).publicKey;
    const candyGuard = await (0, _setup_1.createCandyGuard)(umi, {
        guards: {
            botTax: (0, umi_1.some)({ lamports: (0, umi_1.sol)(0.01), lastInstruction: true }),
        },
        groups: [
            {
                label: 'OLD1',
                guards: {
                    startDate: (0, umi_1.some)({ date: '2022-09-13T10:00:00.000Z' }),
                    solPayment: (0, umi_1.some)({ lamports: (0, umi_1.sol)(2), destination: treasuryA }),
                },
            },
            {
                label: 'OLD2',
                guards: {
                    startDate: (0, umi_1.some)({ date: '2022-09-13T12:00:00.000Z' }),
                    solPayment: (0, umi_1.some)({ lamports: (0, umi_1.sol)(4), destination: treasuryA }),
                },
            },
        ],
    });
    // When we update all its guards â€” defaults and groups.
    const treasuryB = (0, umi_1.generateSigner)(umi).publicKey;
    await (0, umi_1.transactionBuilder)()
        .add((0, src_1.updateCandyGuard)(umi, {
        candyGuard,
        guards: {
            botTax: (0, umi_1.some)({ lamports: (0, umi_1.sol)(0.02), lastInstruction: false }),
        },
        groups: [
            {
                label: 'NEW1',
                guards: {
                    startDate: (0, umi_1.some)({ date: '2022-09-15T10:00:00.000Z' }),
                    solPayment: (0, umi_1.some)({ lamports: (0, umi_1.sol)(1), destination: treasuryB }),
                    endDate: (0, umi_1.some)({ date: '2022-09-15T12:00:00.000Z' }),
                },
            },
            {
                label: 'NEW2',
                guards: {
                    startDate: (0, umi_1.some)({ date: '2022-09-15T12:00:00.000Z' }),
                    solPayment: (0, umi_1.some)({ lamports: (0, umi_1.sol)(3), destination: treasuryB }),
                },
            },
        ],
    }))
        .sendAndConfirm(umi);
    // Then all guards were updated as expected.
    const candyGuardAccount = await (0, src_1.fetchCandyGuard)(umi, candyGuard);
    t.like(candyGuardAccount, {
        guards: {
            ...src_1.emptyDefaultGuardSetArgs,
            botTax: (0, umi_1.some)({ lamports: (0, umi_1.sol)(0.02), lastInstruction: false }),
        },
        groups: [
            {
                label: 'NEW1',
                guards: {
                    ...src_1.emptyDefaultGuardSetArgs,
                    startDate: (0, umi_1.some)({ date: (0, umi_1.dateTime)('2022-09-15T10:00:00.000Z') }),
                    solPayment: (0, umi_1.some)({ lamports: (0, umi_1.sol)(1), destination: treasuryB }),
                    endDate: (0, umi_1.some)({ date: (0, umi_1.dateTime)('2022-09-15T12:00:00.000Z') }),
                },
            },
            {
                label: 'NEW2',
                guards: {
                    ...src_1.emptyDefaultGuardSetArgs,
                    startDate: (0, umi_1.some)({ date: (0, umi_1.dateTime)('2022-09-15T12:00:00.000Z') }),
                    solPayment: (0, umi_1.some)({ lamports: (0, umi_1.sol)(3), destination: treasuryB }),
                },
            },
        ],
    });
});
(0, ava_1.default)('it can remove all guards from a candy guard', async (t) => {
    // Given an existing candy guard with defaults guards and groups.
    const umi = await (0, _setup_1.createUmi)();
    const destination = (0, umi_1.generateSigner)(umi).publicKey;
    const candyGuard = await (0, _setup_1.createCandyGuard)(umi, {
        guards: {
            botTax: (0, umi_1.some)({ lamports: (0, umi_1.sol)(0.01), lastInstruction: true }),
        },
        groups: [
            {
                label: 'OLD1',
                guards: {
                    startDate: (0, umi_1.some)({ date: '2022-09-13T10:00:00.000Z' }),
                    solPayment: (0, umi_1.some)({ lamports: (0, umi_1.sol)(2), destination }),
                },
            },
            {
                label: 'OLD2',
                guards: {
                    startDate: (0, umi_1.some)({ date: '2022-09-13T12:00:00.000Z' }),
                    solPayment: (0, umi_1.some)({ lamports: (0, umi_1.sol)(4), destination }),
                },
            },
        ],
    });
    // When we update it so that it has no guards.
    await (0, umi_1.transactionBuilder)()
        .add((0, src_1.updateCandyGuard)(umi, { candyGuard, guards: {}, groups: [] }))
        .sendAndConfirm(umi);
    // Then all guards were removed as expected.
    const candyGuardAccount = await (0, src_1.fetchCandyGuard)(umi, candyGuard);
    t.like(candyGuardAccount, {
        guards: src_1.emptyDefaultGuardSetArgs,
        groups: [],
    });
});
(0, ava_1.default)('it can update a single guard by passing the current data', async (t) => {
    // Given an existing candy guard with defaults guards and groups.
    const umi = await (0, _setup_1.createUmi)();
    const destination = (0, umi_1.generateSigner)(umi).publicKey;
    const candyGuard = await (0, _setup_1.createCandyGuard)(umi, {
        guards: {
            botTax: (0, umi_1.some)({ lamports: (0, umi_1.sol)(0.01), lastInstruction: true }),
        },
        groups: [
            {
                label: 'GROUP1',
                guards: {
                    startDate: (0, umi_1.some)({ date: '2022-09-13T10:00:00.000Z' }),
                    solPayment: (0, umi_1.some)({ lamports: (0, umi_1.sol)(2), destination }),
                },
            },
            {
                label: 'GROUP2',
                guards: {
                    startDate: (0, umi_1.some)({ date: '2022-09-13T12:00:00.000Z' }),
                    solPayment: (0, umi_1.some)({ lamports: (0, umi_1.sol)(4), destination }),
                },
            },
        ],
    });
    // And we have access to the data of that candy guard.
    const { guards, groups } = (await (0, src_1.fetchCandyGuard)(umi, candyGuard));
    // When we update one guard from one group and pass in the rest of the data.
    groups[1].guards.startDate = (0, umi_1.some)({ date: '2022-09-13T14:00:00.000Z' });
    await (0, umi_1.transactionBuilder)()
        .add((0, src_1.updateCandyGuard)(umi, { candyGuard, guards, groups }))
        .sendAndConfirm(umi);
    // Then only that guard was updated.
    const candyGuardAccount = await (0, src_1.fetchCandyGuard)(umi, candyGuard);
    t.like(candyGuardAccount, {
        guards: {
            ...src_1.emptyDefaultGuardSetArgs,
            botTax: (0, umi_1.some)({ lamports: (0, umi_1.sol)(0.01), lastInstruction: true }),
        },
        groups: [
            {
                label: 'GROUP1',
                guards: {
                    ...src_1.emptyDefaultGuardSetArgs,
                    startDate: (0, umi_1.some)({ date: (0, umi_1.dateTime)('2022-09-13T10:00:00.000Z') }),
                    solPayment: (0, umi_1.some)({ lamports: (0, umi_1.sol)(2), destination }),
                },
            },
            {
                label: 'GROUP2',
                guards: {
                    ...src_1.emptyDefaultGuardSetArgs,
                    startDate: (0, umi_1.some)({ date: (0, umi_1.dateTime)('2022-09-13T14:00:00.000Z') }),
                    solPayment: (0, umi_1.some)({ lamports: (0, umi_1.sol)(4), destination }),
                },
            },
        ],
    });
});
//# sourceMappingURL=updateCandyGuard.test.js.map