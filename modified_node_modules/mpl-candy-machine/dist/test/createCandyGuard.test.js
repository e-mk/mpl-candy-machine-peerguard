"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const umi_1 = require("@metaplex-foundation/umi");
const umi_bundle_tests_1 = require("@metaplex-foundation/umi-bundle-tests");
const ava_1 = __importDefault(require("ava"));
const src_1 = require("../src");
const _setup_1 = require("./_setup");
(0, ava_1.default)('it can create a candy guard without guards', async (t) => {
    // Given a base address.
    const umi = await (0, _setup_1.createUmi)();
    const base = (0, umi_1.generateSigner)(umi);
    // When we create a new candy guard without guards.
    await (0, umi_1.transactionBuilder)()
        .add((0, src_1.createCandyGuard)(umi, { base }))
        .sendAndConfirm(umi);
    // Then a new candy guard account was created with the expected data.
    const candyGuard = (0, src_1.findCandyGuardPda)(umi, { base: base.publicKey });
    const candyGuardAccount = await (0, src_1.fetchCandyGuard)(umi, candyGuard);
    t.like(candyGuardAccount, {
        publicKey: (0, umi_1.publicKey)(candyGuard),
        base: (0, umi_1.publicKey)(base),
        authority: (0, umi_1.publicKey)(umi.identity),
        guards: src_1.emptyDefaultGuardSetArgs,
        groups: [],
    });
});
(0, ava_1.default)('it can create a candy guard with guards', async (t) => {
    // Given a base address.
    const umi = await (0, _setup_1.createUmi)();
    const base = (0, umi_1.generateSigner)(umi);
    // When we create a new candy guard with guards.
    const solDestination = (0, umi_1.generateSigner)(umi).publicKey;
    const gatekeeperNetwork = (0, umi_1.generateSigner)(umi).publicKey;
    const tokenMint = (0, umi_1.generateSigner)(umi).publicKey;
    const tokenDestination = (0, umi_1.generateSigner)(umi).publicKey;
    await (0, umi_1.transactionBuilder)()
        .add((0, src_1.createCandyGuard)(umi, {
        base,
        guards: {
            botTax: (0, umi_1.some)({ lamports: (0, umi_1.sol)(0.001), lastInstruction: true }),
            solPayment: (0, umi_1.some)({ lamports: (0, umi_1.sol)(1.5), destination: solDestination }),
            startDate: (0, umi_1.some)({ date: '2023-03-07T16:13:00.000Z' }),
            endDate: (0, umi_1.some)({ date: '2023-03-08T16:13:00.000Z' }),
            gatekeeper: (0, umi_1.some)({ gatekeeperNetwork, expireOnUse: true }),
            tokenPayment: (0, umi_1.some)({
                amount: 42,
                mint: tokenMint,
                destinationAta: tokenDestination,
            }),
        },
    }))
        .sendAndConfirm(umi);
    // Then a new candy guard account was created with the expected data.
    const candyGuard = (0, src_1.findCandyGuardPda)(umi, { base: base.publicKey });
    const candyGuardAccount = await (0, src_1.fetchCandyGuard)(umi, candyGuard);
    t.like(candyGuardAccount, {
        publicKey: (0, umi_1.publicKey)(candyGuard),
        base: (0, umi_1.publicKey)(base),
        authority: (0, umi_1.publicKey)(umi.identity),
        guards: {
            ...src_1.emptyDefaultGuardSetArgs,
            botTax: (0, umi_1.some)({ lamports: (0, umi_1.sol)(0.001), lastInstruction: true }),
            solPayment: (0, umi_1.some)({ lamports: (0, umi_1.sol)(1.5), destination: solDestination }),
            startDate: (0, umi_1.some)({ date: (0, umi_1.dateTime)('2023-03-07T16:13:00.000Z') }),
            endDate: (0, umi_1.some)({ date: (0, umi_1.dateTime)('2023-03-08T16:13:00.000Z') }),
            gatekeeper: (0, umi_1.some)({ gatekeeperNetwork, expireOnUse: true }),
            tokenPayment: (0, umi_1.some)({
                amount: 42n,
                mint: tokenMint,
                destinationAta: tokenDestination,
            }),
        },
        groups: [],
    });
});
(0, ava_1.default)('it can create a candy guard with guard groups', async (t) => {
    // Given a base address.
    const umi = await (0, _setup_1.createUmi)();
    const base = (0, umi_1.generateSigner)(umi);
    // When we create a new candy guard with guard groups.
    const solDestination = (0, umi_1.generateSigner)(umi).publicKey;
    const gatekeeperNetwork = (0, umi_1.generateSigner)(umi).publicKey;
    const tokenGateMint = (0, umi_1.generateSigner)(umi).publicKey;
    const merkleRoot = new Uint8Array(Array(32).fill(42));
    await (0, umi_1.transactionBuilder)()
        .add((0, src_1.createCandyGuard)(umi, {
        base,
        guards: {
            // Bot tax for all groups.
            botTax: (0, umi_1.some)({ lamports: (0, umi_1.sol)(0.01), lastInstruction: false }),
            // Mint finished after 24h for all groups.
            endDate: (0, umi_1.some)({ date: '2022-09-06T16:00:00.000Z' }),
        },
        groups: [
            {
                // First group for VIPs.
                label: 'VIP',
                guards: {
                    startDate: (0, umi_1.some)({ date: '2022-09-05T16:00:00.000Z' }),
                    allowList: (0, umi_1.some)({ merkleRoot }),
                    solPayment: (0, umi_1.some)({
                        lamports: (0, umi_1.sol)(1),
                        destination: solDestination,
                    }),
                },
            },
            {
                // Second group for whitelist token holders.
                label: 'WLIST',
                guards: {
                    startDate: (0, umi_1.some)({ date: '2022-09-05T18:00:00.000Z' }),
                    tokenGate: (0, umi_1.some)({ mint: tokenGateMint, amount: 1 }),
                    solPayment: (0, umi_1.some)({
                        lamports: (0, umi_1.sol)(2),
                        destination: solDestination,
                    }),
                },
            },
            {
                // Third group for the public.
                label: 'PUBLIC',
                guards: {
                    startDate: (0, umi_1.some)({ date: '2022-09-05T20:00:00.000Z' }),
                    gatekeeper: (0, umi_1.some)({ gatekeeperNetwork, expireOnUse: false }),
                    solPayment: (0, umi_1.some)({
                        lamports: (0, umi_1.sol)(3),
                        destination: solDestination,
                    }),
                },
            },
        ],
    }))
        .sendAndConfirm(umi);
    // Then a new candy guard account was created with the expected data.
    const candyGuard = (0, src_1.findCandyGuardPda)(umi, { base: base.publicKey });
    const candyGuardAccount = await (0, src_1.fetchCandyGuard)(umi, candyGuard);
    t.like(candyGuardAccount, {
        publicKey: (0, umi_1.publicKey)(candyGuard),
        guards: {
            ...src_1.emptyDefaultGuardSetArgs,
            botTax: (0, umi_1.some)({ lamports: (0, umi_1.sol)(0.01), lastInstruction: false }),
            endDate: (0, umi_1.some)({ date: (0, umi_1.dateTime)('2022-09-06T16:00:00.000Z') }),
        },
        groups: [
            {
                label: 'VIP',
                guards: {
                    ...src_1.emptyDefaultGuardSetArgs,
                    startDate: (0, umi_1.some)({ date: (0, umi_1.dateTime)('2022-09-05T16:00:00.000Z') }),
                    allowList: (0, umi_1.some)({ merkleRoot }),
                    solPayment: (0, umi_1.some)({
                        lamports: (0, umi_1.sol)(1),
                        destination: (0, umi_1.publicKey)(solDestination),
                    }),
                },
            },
            {
                label: 'WLIST',
                guards: {
                    ...src_1.emptyDefaultGuardSetArgs,
                    startDate: (0, umi_1.some)({ date: (0, umi_1.dateTime)('2022-09-05T18:00:00.000Z') }),
                    tokenGate: (0, umi_1.some)({ mint: tokenGateMint, amount: 1n }),
                    solPayment: (0, umi_1.some)({
                        lamports: (0, umi_1.sol)(2),
                        destination: (0, umi_1.publicKey)(solDestination),
                    }),
                },
            },
            {
                label: 'PUBLIC',
                guards: {
                    ...src_1.emptyDefaultGuardSetArgs,
                    startDate: (0, umi_1.some)({ date: (0, umi_1.dateTime)('2022-09-05T20:00:00.000Z') }),
                    gatekeeper: (0, umi_1.some)({ gatekeeperNetwork, expireOnUse: false }),
                    solPayment: (0, umi_1.some)({
                        lamports: (0, umi_1.sol)(3),
                        destination: (0, umi_1.publicKey)(solDestination),
                    }),
                },
            },
        ],
    });
});
(0, ava_1.default)('it fails to create a group with a label that is too long', async (t) => {
    // Given a base address.
    const umi = await (0, _setup_1.createUmi)();
    const base = (0, umi_1.generateSigner)(umi);
    // When we try to create a new Candy Guard with a group label that is too long.
    const createInstruction = () => (0, src_1.createCandyGuard)(umi, {
        base,
        guards: {},
        groups: [{ label: 'IAMALABELTHATISTOOLONG', guards: {} }],
    });
    // Then we expect a program error.
    t.throws(createInstruction, {
        message: /The provided group label \[IAMALABELTHATISTOOLONG\] is too long/,
    });
});
(0, ava_1.default)('it can create a candy guard with an explicit authority', async (t) => {
    // Given a base address and an explicit authority.
    const umi = await (0, _setup_1.createUmi)();
    const base = (0, umi_1.generateSigner)(umi);
    const authority = (0, umi_1.generateSigner)(umi).publicKey;
    // When we create a new Candy Guard using that authority.
    await (0, umi_1.transactionBuilder)()
        .add((0, src_1.createCandyGuard)(umi, { base, authority }))
        .sendAndConfirm(umi);
    // Then we expect the Candy Guard's authority to be the given authority.
    const candyGuard = (0, src_1.findCandyGuardPda)(umi, { base: base.publicKey });
    const candyGuardAccount = await (0, src_1.fetchCandyGuard)(umi, candyGuard);
    t.like(candyGuardAccount, {
        publicKey: (0, umi_1.publicKey)(candyGuard),
        base: (0, umi_1.publicKey)(base),
        authority: (0, umi_1.publicKey)(authority),
    });
});
(0, ava_1.default)('it can create a candy guard with an explicit payer', async (t) => {
    // Given a base address and an explicit payer with SOLs.
    const umi = await (0, _setup_1.createUmi)();
    const base = (0, umi_1.generateSigner)(umi);
    const payer = await (0, umi_bundle_tests_1.generateSignerWithSol)(umi);
    const payerBalance = await umi.rpc.getBalance(payer.publicKey);
    // When we create a new Candy Guard using that authority.
    const builder = (0, umi_1.transactionBuilder)().add((0, src_1.createCandyGuard)(umi, { base, payer }));
    await builder.sendAndConfirm(umi);
    // Then the Candy Guard was created successfully.
    const [candyGuard] = (0, src_1.findCandyGuardPda)(umi, { base: base.publicKey });
    t.true(await umi.rpc.accountExists(candyGuard));
    // And the payer paid for the rent.
    const newPayerBalance = await umi.rpc.getBalance(payer.publicKey);
    const expectedRent = await builder.getRentCreatedOnChain(umi);
    t.deepEqual(newPayerBalance, (0, umi_1.subtractAmounts)(payerBalance, expectedRent));
});
//# sourceMappingURL=createCandyGuard.test.js.map