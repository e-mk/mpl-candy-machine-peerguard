"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable no-promise-executor-return */
const mpl_token_metadata_1 = require("@metaplex-foundation/mpl-token-metadata");
const mpl_toolbox_1 = require("@metaplex-foundation/mpl-toolbox");
const umi_1 = require("@metaplex-foundation/umi");
const ava_1 = __importDefault(require("ava"));
const src_1 = require("../src");
const _setup_1 = require("./_setup");
(0, ava_1.default)('it can create a LUT for a candy machine v2', async (t) => {
    // Given a candy machine with a candy guard.
    const umi = await (0, _setup_1.createUmi)();
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        configLines: [{ name: 'Degen #1', uri: 'https://example.com/degen/1' }],
        guards: {},
    });
    // And given a transaction builder that mints an NFT without an LUT.
    const mint = (0, umi_1.generateSigner)(umi);
    const builderWithoutLut = (0, umi_1.transactionBuilder)()
        .add((0, mpl_toolbox_1.setComputeUnitLimit)(umi, { units: 600000 }))
        .add((0, src_1.mintV2)(umi, {
        candyMachine,
        nftMint: mint,
        collectionMint,
        collectionUpdateAuthority: umi.identity.publicKey,
    }));
    // When we create a LUT for the candy machine.
    const recentSlot = await umi.rpc.getSlot({ commitment: 'finalized' });
    const [lutBuilder, lut] = await (0, src_1.createLutForCandyMachine)(umi, recentSlot, candyMachine);
    await lutBuilder.sendAndConfirm(umi);
    // Then we expect the LUT addresses to be the following.
    const [collectionAuthorityPda] = (0, src_1.findCandyMachineAuthorityPda)(umi, {
        candyMachine,
    });
    t.deepEqual([...lut.addresses].sort(), [
        candyMachine,
        (0, src_1.findCandyGuardPda)(umi, { base: candyMachine })[0],
        collectionMint,
        (0, mpl_token_metadata_1.findMetadataPda)(umi, { mint: collectionMint })[0],
        (0, mpl_token_metadata_1.findMasterEditionPda)(umi, { mint: collectionMint })[0],
        umi.identity.publicKey,
        collectionAuthorityPda,
        (0, mpl_token_metadata_1.findMetadataDelegateRecordPda)(umi, {
            mint: collectionMint,
            delegateRole: mpl_token_metadata_1.MetadataDelegateRole.Collection,
            updateAuthority: umi.identity.publicKey,
            delegate: collectionAuthorityPda,
        })[0],
        (0, mpl_toolbox_1.getSysvar)('instructions'),
        (0, mpl_toolbox_1.getSysvar)('slotHashes'),
        (0, mpl_toolbox_1.getSplTokenProgramId)(umi),
        (0, mpl_toolbox_1.getSplAssociatedTokenProgramId)(umi),
        (0, mpl_token_metadata_1.getMplTokenMetadataProgramId)(umi),
        (0, src_1.getMplCandyMachineCoreProgramId)(umi),
    ].sort());
    // And we expect the mint builder to be smaller with the LUT.
    const builderWithLut = builderWithoutLut.setAddressLookupTables([lut]);
    const transactionSizeDifference = builderWithoutLut.getTransactionSize(umi) -
        builderWithLut.getTransactionSize(umi);
    const expectedSizeDifference = (32 - 1) * 13 + // Replaces keys with indexes for 13 out of 14 addresses (one is a Signer).
        -32 + // Adds 32 bytes for the LUT address itself.
        -2; // Adds 2 bytes for writable and readonly array sizes.
    t.is(transactionSizeDifference, expectedSizeDifference);
    // And we can use the builder with LUT to mint an NFT
    // providing we wait a little bit for the LUT to become active.
    await new Promise((resolve) => setTimeout(resolve, 1000));
    await builderWithLut.sendAndConfirm(umi);
    await (0, _setup_1.assertSuccessfulMint)(t, umi, { mint, owner: umi.identity });
});
(0, ava_1.default)('it can create a LUT for a candy machine v1', async (t) => {
    // Given a candy machine v1 with a candy guard.
    const umi = await (0, _setup_1.createUmi)();
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const { publicKey: candyMachine } = await (0, _setup_1.createV1)(umi, {
        collectionMint,
        configLines: [{ name: 'Degen #1', uri: 'https://example.com/degen/1' }],
        guards: {},
    });
    // When we create a LUT for the candy machine.
    const recentSlot = await umi.rpc.getSlot({ commitment: 'finalized' });
    const [, lut] = await (0, src_1.createLutForCandyMachine)(umi, recentSlot, candyMachine);
    // Then we expect the LUT addresses to contain the legacy collection authority Record.
    const [collectionAuthorityPda] = (0, src_1.findCandyMachineAuthorityPda)(umi, {
        candyMachine,
    });
    const [collectionAuthorityRecord] = (0, mpl_token_metadata_1.findCollectionAuthorityRecordPda)(umi, {
        mint: collectionMint,
        collectionAuthority: collectionAuthorityPda,
    });
    t.true(lut.addresses.includes(collectionAuthorityRecord));
});
(0, ava_1.default)('it can create a LUT for a candy machine with no candy guard', async (t) => {
    // Given a candy machine with no candy guard.
    const umi = await (0, _setup_1.createUmi)();
    const collectionMint = (await (0, _setup_1.createCollectionNft)(umi)).publicKey;
    const { publicKey: candyMachine } = await (0, _setup_1.createV2)(umi, {
        collectionMint,
        configLines: [{ name: 'Degen #1', uri: 'https://example.com/degen/1' }],
    });
    // And a custom mint authority.
    const mintAuthority = (0, umi_1.generateSigner)(umi);
    await (0, src_1.setMintAuthority)(umi, {
        candyMachine,
        mintAuthority,
    }).sendAndConfirm(umi);
    // When we create a LUT for the candy machine.
    const recentSlot = await umi.rpc.getSlot({ commitment: 'finalized' });
    const [, lut] = await (0, src_1.createLutForCandyMachine)(umi, recentSlot, candyMachine);
    // Then we expect the LUT addresses to contain the mint authority.
    t.true(lut.addresses.includes(mintAuthority.publicKey));
});
//# sourceMappingURL=createLutForCandyMachine.test.js.map